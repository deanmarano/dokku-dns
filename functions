#!/usr/bin/env bash
# DNS Plugin Functions
source "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/config"
set -eo pipefail
[[ $DOKKU_TRACE ]] && set -x

# Load dokku functions if available
if [[ -f "$PLUGIN_CORE_AVAILABLE_PATH/common/functions" ]]; then
  source "$PLUGIN_CORE_AVAILABLE_PATH/common/functions"
fi

# Define missing functions if needed
if ! declare -f dokku_log_info1 >/dev/null 2>&1; then
  dokku_log_info1() { echo "-----> $*"; }
fi

if ! declare -f dokku_log_info2 >/dev/null 2>&1; then
  dokku_log_info2() { echo "=====> $*"; }
fi

if ! declare -f dokku_log_warn >/dev/null 2>&1; then
  dokku_log_warn() { echo " !     $*"; }
fi

if ! declare -f dokku_log_fail >/dev/null 2>&1; then
  dokku_log_fail() {
    echo " !     $*" >&2
    exit 1
  }
fi

# DNS-specific functions
# These functions are available to other plugins that source this file

# Public API Functions (safe for other plugins to use)

# Get all domains configured for a specific app
# Usage: get_app_domains <app>
# Returns: newline-separated list of domains
get_app_domains() {
  local APP="$1"
  local domains_output
  # Use dokku domains:report to get app domains
  # Note: This is acceptable as it's using the domains plugin API correctly
  domains_output=$(dokku domains:report "$APP" --domains-app-vhosts 2>/dev/null || echo "")

  # Convert space-separated domains to newline-separated for proper array processing
  if [[ -n "$domains_output" ]]; then
    for domain in $domains_output; do
      echo "$domain"
    done
  fi
}

# Get list of all apps currently managed by DNS plugin
# Usage: get_dns_managed_apps
# Returns: newline-separated list of app names
get_dns_managed_apps() {
  local LINKS_FILE="$PLUGIN_DATA_ROOT/LINKS"

  if [[ -f "$LINKS_FILE" ]]; then
    cat "$LINKS_FILE" 2>/dev/null || echo ""
  fi
}

# Check if an app is currently managed by DNS plugin
# Usage: is_app_dns_managed <app>
# Returns: 0 if managed, 1 if not managed
is_app_dns_managed() {
  local APP="$1"
  local LINKS_FILE="$PLUGIN_DATA_ROOT/LINKS"

  if [[ -f "$LINKS_FILE" ]] && grep -q "^$APP$" "$LINKS_FILE" 2>/dev/null; then
    return 0
  else
    return 1
  fi
}

# Zone management functions
zones_set_enabled() {
  local ZONE="$1"
  local ENABLED_ZONES_FILE="$PLUGIN_DATA_ROOT/ENABLED_ZONES"

  mkdir -p "$PLUGIN_DATA_ROOT"

  # Add zone to enabled zones if not already present
  if [[ ! -f "$ENABLED_ZONES_FILE" ]] || ! grep -q "^$ZONE$" "$ENABLED_ZONES_FILE"; then
    echo "$ZONE" >>"$ENABLED_ZONES_FILE"
  fi
}

zones_set_disabled() {
  local ZONE="$1"
  local ENABLED_ZONES_FILE="$PLUGIN_DATA_ROOT/ENABLED_ZONES"

  if [[ -f "$ENABLED_ZONES_FILE" ]]; then
    # Remove the zone from enabled zones file
    local temp_file
    temp_file=$(mktemp)
    grep -v "^$ZONE$" "$ENABLED_ZONES_FILE" >"$temp_file" || true

    # If file is empty after removal, delete it
    if [[ ! -s "$temp_file" ]]; then
      rm -f "$ENABLED_ZONES_FILE"
    else
      mv "$temp_file" "$ENABLED_ZONES_FILE"
    fi

    rm -f "$temp_file"
  fi
}

# Check if a domain is in an enabled hosted zone
# Usage: is_domain_in_enabled_zone <domain>
# Returns: 0 if domain is in enabled zone, 1 if not
is_domain_in_enabled_zone() {
  local DOMAIN="$1"
  local ENABLED_ZONES_FILE="$PLUGIN_DATA_ROOT/ENABLED_ZONES"

  # If no enabled zones file exists, return false (no zones enabled)
  if [[ ! -f "$ENABLED_ZONES_FILE" ]]; then
    return 1
  fi

  # If file exists but is empty, no zones are enabled
  if [[ ! -s "$ENABLED_ZONES_FILE" ]]; then
    return 1
  fi

  # Check if domain matches any enabled zone
  while IFS= read -r zone; do
    [[ -z "$zone" ]] && continue

    # Check if domain matches this zone exactly or is a subdomain
    if [[ "$DOMAIN" == "$zone" ]] || [[ "$DOMAIN" == *".$zone" ]]; then
      return 0 # Domain is in an enabled zone
    fi
  done <"$ENABLED_ZONES_FILE"

  return 1 # Domain not in any enabled zone
}

# Get list of enabled zones
# Usage: get_enabled_zones
# Returns: newline-separated list of enabled zone names
get_enabled_zones() {
  local ENABLED_ZONES_FILE="$PLUGIN_DATA_ROOT/ENABLED_ZONES"

  if [[ -f "$ENABLED_ZONES_FILE" ]]; then
    cat "$ENABLED_ZONES_FILE" 2>/dev/null || echo ""
  fi
}

# Check if a zone is enabled
# Usage: is_zone_enabled <zone>
# Returns: 0 if zone is enabled, 1 if not
is_zone_enabled() {
  local ZONE="$1"
  local ENABLED_ZONES_FILE="$PLUGIN_DATA_ROOT/ENABLED_ZONES"

  if [[ -f "$ENABLED_ZONES_FILE" ]] && grep -q "^$ZONE$" "$ENABLED_ZONES_FILE" 2>/dev/null; then
    return 0
  else
    return 1
  fi
}

dns_get_record_ip() {
  local DOMAIN="$1"

  # Try DNS provider checking first (bypasses DNS caching)
  local ADAPTER_PATH
  ADAPTER_PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/providers/adapter.sh"
  if [[ -f "$ADAPTER_PATH" ]]; then
    source "$ADAPTER_PATH"
    if init_provider_system >/dev/null 2>&1; then
      local provider_ip
      if provider_ip=$(dns_get_record "$DOMAIN" "A" 2>/dev/null) && [[ -n "$provider_ip" ]]; then
        echo "$provider_ip"
        return 0
      fi
    fi
  fi

  # Fallback to DNS resolution (may be cached)
  local current_ip
  current_ip=$(dig +short "$DOMAIN" A 2>/dev/null | tail -n1 || echo "")
  if [[ -n "$current_ip" ]]; then
    echo "$current_ip"
    return 0
  fi

  return 1
}

dns_get_server_ip() {
  # Try to get the server's public IP using multiple methods
  local SERVER_IP

  # First try to use global domains to resolve server IP
  local GLOBAL_DOMAINS
  # Use dokku domains:report to get global domains
  # Note: This is acceptable as it's using the domains plugin API correctly
  GLOBAL_DOMAINS=$(dokku domains:report --domains-global-vhosts 2>/dev/null || echo "")

  if [[ -n "$GLOBAL_DOMAINS" ]]; then
    # Use the first global domain to resolve server IP
    local FIRST_GLOBAL_DOMAIN
    FIRST_GLOBAL_DOMAIN=$(echo "$GLOBAL_DOMAINS" | head -n1)
    SERVER_IP=$(dig +short "$FIRST_GLOBAL_DOMAIN" | tail -n1 2>/dev/null || echo "")
  fi

  # If no global domains or couldn't resolve, try to get server IP another way
  if [[ -z "$SERVER_IP" ]]; then
    # Try to get the server's public IP
    SERVER_IP=$(curl -s --max-time 3 ifconfig.me 2>/dev/null || curl -s --max-time 3 ipecho.net/plain 2>/dev/null || curl -s --max-time 3 icanhazip.com 2>/dev/null || echo "")
  fi

  if [[ -z "$SERVER_IP" ]]; then
    dokku_log_fail "Could not determine server IP. Please ensure your server has internet access or configure global domains."
  fi

  echo "$SERVER_IP"
}

dns_app() {
  local APP="$1"

  # Load provider adapter system
  local ADAPTER_PATH
  ADAPTER_PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/providers/adapter.sh"
  if [[ ! -f "$ADAPTER_PATH" ]]; then
    dokku_log_fail "Provider adapter not found at $ADAPTER_PATH"
  fi
  source "$ADAPTER_PATH"

  # Initialize provider system and sync the app
  if init_provider_system >/dev/null 2>&1; then
    dns_sync_app "$APP"
    return 0
  else
    dokku_log_fail "No working DNS provider found"
  fi
}

dns_add_app_domains() {
  local APP="$1"
  local TTL="$2"
  shift 2
  local DOMAINS=("$@")

  # If no domains specified, get all domains for the app
  if [[ ${#DOMAINS[@]} -eq 0 ]]; then
    local APP_DOMAINS
    # Use dokku domains:report to get app domains
    # Note: This is acceptable as it's using the domains plugin API correctly
    APP_DOMAINS=$(dokku domains:report "$APP" --domains-app-vhosts 2>/dev/null || echo "")

    if [[ -z "$APP_DOMAINS" ]]; then
      dokku_log_warn "No domains configured for app: $APP"
      dokku_log_info1 "Add domains with: dokku domains:add $APP <domain>"
      return 0
    fi

    # Convert space-separated domains to array
    read -ra DOMAINS <<<"$APP_DOMAINS"
  fi

  if [[ ${#DOMAINS[@]} -eq 0 ]]; then
    dokku_log_warn "No domains to add for app: $APP"
    return 0
  fi

  # Check which domains are already added to DNS for this app
  local APP_DOMAINS_FILE="$PLUGIN_DATA_ROOT/$APP/DOMAINS"
  local ALREADY_ADDED_DOMAINS=()
  local NEW_DOMAINS=()

  # Get list of already added domains for this app
  if [[ -f "$APP_DOMAINS_FILE" ]]; then
    while IFS= read -r domain; do
      [[ -n "$domain" ]] && ALREADY_ADDED_DOMAINS+=("$domain")
    done <"$APP_DOMAINS_FILE"
  fi

  # Separate already-added domains from new domains
  for DOMAIN in "${DOMAINS[@]}"; do
    [[ -z "$DOMAIN" ]] && continue

    local IS_ALREADY_ADDED=false
    for ADDED_DOMAIN in "${ALREADY_ADDED_DOMAINS[@]}"; do
      if [[ "$DOMAIN" == "$ADDED_DOMAIN" ]]; then
        IS_ALREADY_ADDED=true
        break
      fi
    done

    if [[ "$IS_ALREADY_ADDED" == true ]]; then
      # Domain is already added, don't process it again
      continue
    else
      NEW_DOMAINS+=("$DOMAIN")
    fi
  done

  # Show status of already-added domains
  if [[ ${#ALREADY_ADDED_DOMAINS[@]} -gt 0 ]]; then
    dokku_log_info1 "Already added domains for app '$APP':"
    for DOMAIN in "${ALREADY_ADDED_DOMAINS[@]}"; do
      # Only show if it's in the current request
      local SHOW_DOMAIN=false
      for REQUESTED_DOMAIN in "${DOMAINS[@]}"; do
        if [[ "$DOMAIN" == "$REQUESTED_DOMAIN" ]]; then
          SHOW_DOMAIN=true
          break
        fi
      done

      if [[ "$SHOW_DOMAIN" == true ]]; then
        dokku_log_info1 "  ✓ $DOMAIN (already in DNS management)"
      fi
    done
    echo
  fi

  # If no new domains to add, show message and exit
  if [[ ${#NEW_DOMAINS[@]} -eq 0 ]]; then
    if [[ ${#ALREADY_ADDED_DOMAINS[@]} -gt 0 ]]; then
      dokku_log_info1 "All requested domains are already added to DNS management"
    else
      dokku_log_warn "No domains to add for app: $APP"
    fi
    return 0
  fi

  dokku_log_info1 "Processing ${#NEW_DOMAINS[@]} new domain(s) for app '$APP':"
  for domain in "${NEW_DOMAINS[@]}"; do
    dokku_log_info1 "  • $domain"
  done
  echo

  # Filter new domains to only include those with hosted zones
  local VALID_DOMAINS=()
  local SKIPPED_DOMAINS=()

  dokku_log_info1 "Filtering domains - Using provider system, New domains: ${#NEW_DOMAINS[@]}"

  # Load provider adapter system
  local ADAPTER_PATH
  ADAPTER_PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/providers/adapter.sh"

  # Check if any provider is available and configured
  local PROVIDER_AVAILABLE=false
  if [[ -f "$ADAPTER_PATH" ]]; then
    source "$ADAPTER_PATH"
    # Try to initialize provider system to check availability
    if init_provider_system >/dev/null 2>&1; then
      PROVIDER_AVAILABLE=true
    fi
  fi

  if [[ -f "$ADAPTER_PATH" ]] && [[ "$PROVIDER_AVAILABLE" == "true" ]]; then
    # Provider system is available - check zones for domain validation
    dokku_log_info1 "Provider system ready - checking zones for new domains..."

    for DOMAIN in "${NEW_DOMAINS[@]}"; do
      [[ -z "$DOMAIN" ]] && continue

      dokku_log_info1 "Checking domain: $DOMAIN"
      # Check if domain can be managed by any provider
      if dns_validate_domain "$DOMAIN"; then
        # Check if this domain is in an enabled zone
        if is_domain_in_enabled_zone "$DOMAIN"; then
          VALID_DOMAINS+=("$DOMAIN")
          dokku_log_info1 "✓ $DOMAIN can be managed (zone enabled)"
        else
          SKIPPED_DOMAINS+=("$DOMAIN")
          dokku_log_info1 "✗ $DOMAIN can be managed but zone is not enabled for auto-discovery"
        fi
      else
        SKIPPED_DOMAINS+=("$DOMAIN")
        dokku_log_info1 "✗ $DOMAIN cannot be managed (no provider zone found)"
      fi
      dokku_log_info1 "Finished checking domain: $DOMAIN"
    done
    dokku_log_info1 "Completed zone checks for all domains"
  else
    # Provider system not available/configured or provider script missing - skip validation
    if [[ ! -f "$PROVIDER_SCRIPT" ]]; then
      dokku_log_warn "Provider script not found - adding all new domains without validation"
    else
      dokku_log_info1 "Provider system not available or not configured - adding all new domains without zone validation"
      dokku_log_info1 "Run 'dokku $PLUGIN_COMMAND_PREFIX:providers:verify' to configure provider credentials for zone validation"
    fi
    VALID_DOMAINS=("${NEW_DOMAINS[@]}")
  fi

  # Report skipped domains
  if [[ ${#SKIPPED_DOMAINS[@]} -gt 0 ]]; then
    dokku_log_warn "Skipping domains without hosted zones or disabled zones:"
    for DOMAIN in "${SKIPPED_DOMAINS[@]}"; do
      # Check if it was skipped due to zone being disabled vs no hosted zone
      local ZONE_ID
      set +e # Temporarily disable exit on error
      ZONE_ID=$(provider_get_zone_id "$DOMAIN" 2>/dev/null)
      local ZONE_EXISTS=$?
      set -e # Re-enable exit on error

      if [[ $ZONE_EXISTS -eq 0 ]] && [[ -n "$ZONE_ID" ]]; then
        dokku_log_info1 "  ❌ $DOMAIN (zone not enabled for auto-discovery)"
      else
        dokku_log_info1 "  ❌ $DOMAIN (no hosted zone found)"
      fi
    done
    echo
  fi

  # Always show status table for all requested domains
  echo
  dns_display_domains_table "$APP" "${NEW_DOMAINS[@]}"

  # Check if we have any valid domains left
  if [[ ${#VALID_DOMAINS[@]} -eq 0 ]]; then
    dokku_log_warn "No domains with enabled hosted zones found for app: $APP"
    if [[ ${#SKIPPED_DOMAINS[@]} -gt 0 ]]; then
      dokku_log_info1 "Enable zones for auto-discovery with: dokku $PLUGIN_COMMAND_PREFIX:zones:enable <zone>"
      dokku_log_info1 "Or create hosted zones for these domains in your DNS provider first"
    fi
    return 0
  fi

  dokku_log_info2 "Adding domains for app '$APP' to DNS (${#VALID_DOMAINS[@]} domains)"

  # Track this app as being added to DNS
  local LINKS_FILE="$PLUGIN_DATA_ROOT/LINKS"
  mkdir -p "$PLUGIN_DATA_ROOT"
  mkdir -p "$PLUGIN_DATA_ROOT/$APP"

  # Add app to LINKS file if not already present
  if [[ ! -f "$LINKS_FILE" ]] || ! grep -q "^$APP$" "$LINKS_FILE" 2>/dev/null; then
    echo "$APP" >>"$LINKS_FILE"
    dokku_log_info1 "App '$APP' added to DNS"
  else
    dokku_log_info1 "App '$APP' already in DNS, adding new domains"
  fi

  # Add valid domains to the app's domains file
  local APP_TTLS_FILE="$PLUGIN_DATA_ROOT/$APP/DOMAIN_TTLS"
  for DOMAIN in "${VALID_DOMAINS[@]}"; do
    echo "$DOMAIN" >>"$APP_DOMAINS_FILE"

    # Store TTL for this domain if provided
    if [[ -n "$TTL" ]]; then
      echo "$DOMAIN:$TTL" >>"$APP_TTLS_FILE"
    fi
  done

  # Remove duplicates from the domains file
  if [[ -f "$APP_DOMAINS_FILE" ]]; then
    sort -u "$APP_DOMAINS_FILE" >"${APP_DOMAINS_FILE}.tmp"
    mv "${APP_DOMAINS_FILE}.tmp" "$APP_DOMAINS_FILE"
  fi
  # Remove duplicates from the TTLs file
  if [[ -f "$APP_TTLS_FILE" ]]; then
    sort -u "$APP_TTLS_FILE" >"${APP_TTLS_FILE}.tmp"
    mv "${APP_TTLS_FILE}.tmp" "$APP_TTLS_FILE"
  fi

  dokku_log_info1 "${#VALID_DOMAINS[@]} domain(s) with hosted zones have been added to DNS"
  dokku_log_info1 "Next step: dokku $PLUGIN_COMMAND_PREFIX:apps:sync $APP"
}

dns_remove_app() {
  local APP="$1"
  local LINKS_FILE="$PLUGIN_DATA_ROOT/LINKS"

  dokku_log_info2 "Removing app '$APP' from DNS"

  # Check if LINKS file exists
  if [[ ! -f "$LINKS_FILE" ]]; then
    dokku_log_warn "No DNS tracking file found"
    return 0
  fi

  # Remove app from LINKS file
  if grep -q "^$APP$" "$LINKS_FILE" 2>/dev/null; then
    # Create a temporary file without this app
    grep -v "^$APP$" "$LINKS_FILE" >"${LINKS_FILE}.tmp" || true
    mv "${LINKS_FILE}.tmp" "$LINKS_FILE"

    # Remove the app's domains file
    local APP_DOMAINS_FILE="$PLUGIN_DATA_ROOT/$APP/DOMAINS"
    if [[ -f "$APP_DOMAINS_FILE" ]]; then
      rm -f "$APP_DOMAINS_FILE"
    fi

    # Remove the app directory if it's empty
    if [[ -d "$PLUGIN_DATA_ROOT/$APP" ]]; then
      rmdir "$PLUGIN_DATA_ROOT/$APP" 2>/dev/null || true
    fi

    dokku_log_info1 "App '$APP' removed from DNS"
    dokku_log_info1 "Note: Existing DNS records were not deleted"
    dokku_log_info1 "To clean up DNS records, run: dokku $PLUGIN_COMMAND_PREFIX:apps:sync $APP (before removing next time)"
  else
    dokku_log_warn "App '$APP' was not found in DNS tracking"
  fi

  # Clean up empty LINKS file
  if [[ ! -s "$LINKS_FILE" ]]; then
    rm -f "$LINKS_FILE"
    dokku_log_info1 "No apps remaining in DNS - tracking file cleaned up"
  fi
}

dns_display_domains_table() {
  local APP="$1"
  shift
  local DOMAINS=("$@")

  # Get server IP
  local SERVER_IP
  SERVER_IP=$(dns_get_server_ip)

  # Check AWS provider status
  local SYNC_STATUS="Not configured"
  local CREDENTIALS_DIR="$PLUGIN_DATA_ROOT/credentials"

  if [[ -d "$CREDENTIALS_DIR" ]] && [[ -f "$CREDENTIALS_DIR/AWS_ACCESS_KEY_ID" ]]; then
    SYNC_STATUS="Ready"
  elif aws sts get-caller-identity >/dev/null 2>&1; then
    SYNC_STATUS="Ready"
  else
    SYNC_STATUS="Missing auth"
  fi

  # Load provider adapter system if available
  if [[ "$SYNC_STATUS" == "Ready" ]]; then
    local ADAPTER_PATH
    ADAPTER_PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/providers/adapter.sh"
    if [[ -f "$ADAPTER_PATH" ]]; then
      source "$ADAPTER_PATH"
      init_provider_system >/dev/null 2>&1
    fi
  fi

  echo
  dokku_log_info2 "Domain Status Table for app '$APP':"
  printf "%-30s %-8s %-15s %-15s %s\n" "Domain" "Status" "Enabled" "Provider" "Zone (Enabled)"
  printf "%-30s %-8s %-15s %-15s %s\n" "------" "------" "-------" "--------" "---------------"

  for DOMAIN in "${DOMAINS[@]}"; do
    [[ -z "$DOMAIN" ]] && continue

    # Get current DNS resolution (using provider-specific checking if available)
    local CURRENT_IP
    CURRENT_IP=$(dns_get_record_ip "$DOMAIN" || echo "")

    # Determine DNS status emoji
    local DNS_EMOJI="❌"
    if [[ -n "$CURRENT_IP" ]]; then
      if [[ "$CURRENT_IP" == "$SERVER_IP" ]]; then
        DNS_EMOJI="✅"
      else
        DNS_EMOJI="⚠️"
      fi
    fi

    # Try to get hosted zone if AWS is ready
    local HOSTED_ZONE="-"
    local ZONE_ID=""
    if [[ "$SYNC_STATUS" == "Ready" ]]; then
      if declare -f "provider_get_zone_id" >/dev/null 2>&1; then
        ZONE_ID=$(provider_get_zone_id "$DOMAIN" 2>/dev/null || echo "")
        if [[ -n "$ZONE_ID" ]]; then
          # Get the zone name from AWS
          local ZONE_NAME
          ZONE_NAME=$(aws route53 get-hosted-zone --id "$ZONE_ID" --query 'HostedZone.Name' --output text 2>/dev/null | sed 's/\.$//g' || echo "$ZONE_ID")
          # Check if this zone is enabled
          if is_zone_enabled "$ZONE_NAME"; then
            HOSTED_ZONE="$ZONE_NAME ✅"
          else
            HOSTED_ZONE="$ZONE_NAME ❌"
          fi
        else
          HOSTED_ZONE="Not found"
        fi
      fi
    fi

    # Check if domain is enabled based on zone enablement
    local ENABLED_STATUS="No"
    if [[ "$SYNC_STATUS" == "Ready" ]]; then
      if [[ -n "$ZONE_ID" ]]; then
        # Check if the zone is enabled
        if is_domain_in_enabled_zone "$DOMAIN"; then
          ENABLED_STATUS="Yes"
        else
          ENABLED_STATUS="No (zone disabled)"
        fi
      else
        ENABLED_STATUS="No (no hosted zone)"
      fi
    else
      ENABLED_STATUS="No (provider not ready)"
    fi

    printf "%-30s %-8s %-15s %-15s %s\n" "$DOMAIN" "$DNS_EMOJI" "$ENABLED_STATUS" "AWS" "$HOSTED_ZONE"
  done

  echo
  dokku_log_info2 "Status Legend:"
  if [[ -n "$SERVER_IP" ]] && [[ "$SERVER_IP" != "Unknown" ]]; then
    dokku_log_info1 "✅ Points to server IP ($SERVER_IP)"
    dokku_log_info1 "⚠️  Points to different IP"
  else
    dokku_log_info1 "❓ Server IP unknown - cannot validate"
  fi
  dokku_log_info1 "❌ No DNS record found"
}

# Get server's public IP address
# Usage: get_server_ip
# Returns: server's public IP address, or "Unknown" if detection fails
get_server_ip() {
  local SERVER_IP=""
  local GLOBAL_DOMAINS=""

  if command -v dokku >/dev/null 2>&1; then
    GLOBAL_DOMAINS=$(dokku domains:report --domains-global-vhosts 2>/dev/null || echo "")
  fi

  if [[ -n "$GLOBAL_DOMAINS" ]] && command -v dig >/dev/null 2>&1; then
    # Use the first global domain to resolve server IP
    local FIRST_GLOBAL_DOMAIN
    FIRST_GLOBAL_DOMAIN=$(echo "$GLOBAL_DOMAINS" | head -n1)
    local RESOLVED_IP
    RESOLVED_IP=$(dig +short "$FIRST_GLOBAL_DOMAIN" 2>/dev/null | tail -n1 || echo "")
    if [[ -n "$RESOLVED_IP" ]] && [[ "$RESOLVED_IP" != "127.0.0.1" ]]; then
      SERVER_IP="$RESOLVED_IP"
    fi
  fi

  # If no global domains or couldn't resolve, try to get server IP another way
  if [[ -z "$SERVER_IP" ]] && command -v curl >/dev/null 2>&1; then
    # Try to get the server's public IP
    local PUBLIC_IP
    PUBLIC_IP=$(curl -s --max-time 3 ifconfig.me 2>/dev/null || curl -s --max-time 3 ipecho.net/plain 2>/dev/null || curl -s --max-time 3 icanhazip.com 2>/dev/null || echo "")
    if [[ -n "$PUBLIC_IP" ]] && [[ "$PUBLIC_IP" != "127.0.0.1" ]]; then
      SERVER_IP="$PUBLIC_IP"
    fi
  fi

  # If still no IP detected, return Unknown instead of broken localhost
  if [[ -z "$SERVER_IP" ]]; then
    SERVER_IP="Unknown"
  fi

  echo "$SERVER_IP"
}

# Check if a domain points to the server's IP
# Usage: domain_points_to_server <domain>
# Returns: 0 if domain points to server, 1 otherwise (including if server IP can't be detected)
domain_points_to_server() {
  local DOMAIN="$1"
  local SERVER_IP
  SERVER_IP=$(get_server_ip)

  # If we can't detect the server IP, we can't validate - fail safe
  if [[ -z "$SERVER_IP" ]] || [[ "$SERVER_IP" == "Unknown" ]]; then
    return 1
  fi

  if command -v dig >/dev/null 2>&1; then
    local CURRENT_IP
    CURRENT_IP=$(dig +short "$DOMAIN" A 2>/dev/null | tail -n1 || echo "")
    if [[ -n "$CURRENT_IP" ]] && [[ "$CURRENT_IP" == "$SERVER_IP" ]]; then
      return 0
    fi
  fi

  return 1
}

# Check if a domain matches any hosted zone that has managed domains
# Usage: dns_domain_matches_managed_zone <domain>
# Returns: 0 if domain matches a zone with managed domains, 1 otherwise
dns_domain_matches_managed_zone() {
  local DOMAIN="$1"

  # Check if any apps are managed by DNS
  local LINKS_FILE="$PLUGIN_DATA_ROOT/LINKS"
  if [[ ! -f "$LINKS_FILE" ]] || [[ ! -s "$LINKS_FILE" ]]; then
    # No managed apps at all
    return 1
  fi

  # Get all managed domains across all apps
  local all_managed_domains=()
  while IFS= read -r app; do
    [[ -z "$app" ]] && continue
    local APP_DOMAINS_FILE="$PLUGIN_DATA_ROOT/$app/DOMAINS"
    if [[ -f "$APP_DOMAINS_FILE" ]]; then
      while IFS= read -r domain; do
        [[ -n "$domain" ]] && all_managed_domains+=("$domain")
      done <"$APP_DOMAINS_FILE"
    fi
  done <"$LINKS_FILE"

  if [[ ${#all_managed_domains[@]} -eq 0 ]]; then
    # No managed domains at all
    return 1
  fi

  # Extract the zone (root domain) from the input domain
  local domain_zone
  domain_zone=$(extract_root_domain "$DOMAIN")

  # Check if any managed domain shares the same zone
  for managed_domain in "${all_managed_domains[@]}"; do
    local managed_zone
    managed_zone=$(extract_root_domain "$managed_domain")
    if [[ "$domain_zone" == "$managed_zone" ]]; then
      # Found a managed domain in the same zone
      return 0
    fi
  done

  # No managed domains in the same zone
  return 1
}

# Extract root domain from a full domain name
# Usage: extract_root_domain <domain>
# Returns: root domain (e.g., "example.com" from "api.example.com")
extract_root_domain() {
  local DOMAIN="$1"

  # Handle simple cases first
  local part_count
  part_count=$(echo "$DOMAIN" | tr '.' '\n' | wc -l)

  if [[ $part_count -le 2 ]]; then
    # Already a root domain (e.g., "example.com" or "localhost")
    echo "$DOMAIN"
    return 0
  fi

  # For domains with more parts, take the last two parts
  # This works for most cases: api.example.com -> example.com
  echo "$DOMAIN" | awk -F. '{print $(NF-1)"."$NF}'
}

# Compare expected vs current DNS records for an app
# Usage: dns_compare_app_records <app>
# Returns: structured data about pending changes
dns_compare_app_records() {
  local APP="$1"
  local SERVER_IP
  SERVER_IP=$(get_server_ip)

  # If we can't detect server IP, return empty
  if [[ -z "$SERVER_IP" ]] || [[ "$SERVER_IP" == "Unknown" ]]; then
    return 1
  fi

  # Get app domains
  local APP_DOMAINS
  APP_DOMAINS=$(get_app_domains "$APP" 2>/dev/null || echo "")

  if [[ -z "$APP_DOMAINS" ]]; then
    return 1
  fi

  # Load provider system for DNS checking
  local PROVIDERS_DIR
  PROVIDERS_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/providers"
  if [[ -f "$PROVIDERS_DIR/loader.sh" ]]; then
    source "$PROVIDERS_DIR/loader.sh"
    if ! auto_load_provider >/dev/null 2>&1; then
      return 1
    fi
  else
    return 1
  fi

  # Check each domain
  while IFS= read -r DOMAIN; do
    [[ -z "$DOMAIN" ]] && continue

    # Get current DNS record
    local zone_id
    if zone_id=$(provider_get_zone_id "$DOMAIN" 2>/dev/null); then
      local current_ip
      current_ip=$(provider_get_record "$zone_id" "$DOMAIN" "A" 2>/dev/null || echo "")

      if [[ -z "$current_ip" ]]; then
        # No record exists - needs to be added
        echo "ADD:$DOMAIN:$SERVER_IP"
      elif [[ "$current_ip" != "$SERVER_IP" ]]; then
        # Record exists but wrong IP - needs to be updated
        echo "UPDATE:$DOMAIN:$SERVER_IP:$current_ip"
      else
        # Record exists and is correct
        echo "CORRECT:$DOMAIN:$SERVER_IP"
      fi
    else
      # No zone found - needs to be added (if zone management allows)
      echo "ADD:$DOMAIN:$SERVER_IP"
    fi
  done <<<"$APP_DOMAINS"
}

# Display pending changes for an app in a formatted way
# Usage: dns_display_pending_changes <app>
dns_display_pending_changes() {
  local APP="$1"
  local changes

  # Get the pending changes
  if ! changes=$(dns_compare_app_records "$APP"); then
    dokku_log_info1 "Unable to determine pending changes (missing server IP or DNS provider)"
    return 1
  fi

  if [[ -z "$changes" ]]; then
    dokku_log_info1 "No domains configured for analysis"
    return 0
  fi

  # Count different types of changes
  local add_count=0
  local update_count=0
  local correct_count=0

  # Display changes and count them
  echo
  dokku_log_info2 "Pending DNS Changes:"

  while IFS= read -r change; do
    [[ -z "$change" ]] && continue

    local action domain target_ip current_ip
    IFS=':' read -r action domain target_ip current_ip <<<"$change"

    case "$action" in
      ADD)
        echo "  + $domain → $target_ip (A record)"
        ((add_count++))
        ;;
      UPDATE)
        echo "  ~ $domain → $target_ip [was: $current_ip]"
        ((update_count++))
        ;;
      CORRECT)
        echo "  ✓ $domain → $target_ip (A record)"
        ((correct_count++))
        ;;
    esac
  done <<<"$changes"

  # Display summary
  echo
  local total_changes=$((add_count + update_count))
  if [[ $total_changes -eq 0 ]]; then
    dokku_log_info1 "Plan: No changes needed - all records are correct"
  else
    dokku_log_info1 "Plan: $add_count to add, $update_count to change, 0 to destroy"
  fi

  return 0
}

# Display pending changes for all DNS-managed apps
# Usage: dns_display_global_pending_changes
dns_display_global_pending_changes() {
  local APPS_LIST
  APPS_LIST=$(get_dns_managed_apps)

  if [[ -z "$APPS_LIST" ]]; then
    return 0
  fi

  local global_add_count=0
  local global_update_count=0
  local global_correct_count=0
  local any_changes_found=false

  echo
  dokku_log_info2 "Pending DNS Changes - All Apps:"

  while IFS= read -r APP; do
    [[ -z "$APP" ]] && continue

    local changes
    if changes=$(dns_compare_app_records "$APP" 2>/dev/null); then
      if [[ -n "$changes" ]]; then
        local app_has_changes=false
        local add_count=0
        local update_count=0

        # Check if this app has any pending changes
        while IFS= read -r change; do
          [[ -z "$change" ]] && continue
          local action
          IFS=':' read -r action _ _ _ <<<"$change"
          case "$action" in
            ADD)
              ((add_count++))
              app_has_changes=true
              ;;
            UPDATE)
              ((update_count++))
              app_has_changes=true
              ;;
            CORRECT) ((global_correct_count++)) ;;
          esac
        done <<<"$changes"

        if [[ "$app_has_changes" == "true" ]]; then
          any_changes_found=true
          echo
          dokku_log_info1 "App: $APP"

          # Display the changes for this app
          while IFS= read -r change; do
            [[ -z "$change" ]] && continue

            local action domain target_ip current_ip
            IFS=':' read -r action domain target_ip current_ip <<<"$change"

            case "$action" in
              ADD)
                echo "    + $domain → $target_ip (A record)"
                ((global_add_count++))
                ;;
              UPDATE)
                echo "    ~ $domain → $target_ip [was: $current_ip]"
                ((global_update_count++))
                ;;
            esac
          done <<<"$changes"
        fi
      fi
    fi
  done <<<"$APPS_LIST"

  # Display global summary
  echo
  if [[ "$any_changes_found" == "true" ]]; then
    dokku_log_info1 "Global Plan: $global_add_count to add, $global_update_count to change, 0 to destroy"
    echo
    dokku_log_info1 "To apply changes:"
    dokku_log_info1 "  Single app: dokku $PLUGIN_COMMAND_PREFIX:apps:sync <app>"
    dokku_log_info1 "  All apps: for app in \$(dokku apps:list 2>/dev/null | tail -n +2); do dokku $PLUGIN_COMMAND_PREFIX:apps:sync \$app; done"
  else
    dokku_log_info1 "Global Plan: No changes needed - all records are correct"
  fi

  return 0
}

# Get the global TTL configuration
# Usage: get_global_ttl
# Returns: TTL value in seconds (default: 300)
get_global_ttl() {
  local TTL_CONFIG_FILE="$PLUGIN_DATA_ROOT/GLOBAL_TTL"

  if [[ -f "$TTL_CONFIG_FILE" ]]; then
    local ttl_value
    ttl_value=$(cat "$TTL_CONFIG_FILE" 2>/dev/null)
    if [[ -n "$ttl_value" && "$ttl_value" =~ ^[0-9]+$ ]]; then
      echo "$ttl_value"
      return 0
    fi
  fi

  # Default TTL
  echo "300"
}

get_domain_ttl() {
  local app="$1"
  local domain="$2"
  local APP_TTLS_FILE="$PLUGIN_DATA_ROOT/$app/DOMAIN_TTLS"

  # Check for domain-specific TTL first
  if [[ -f "$APP_TTLS_FILE" ]]; then
    local domain_ttl
    domain_ttl=$(grep "^$domain:" "$APP_TTLS_FILE" 2>/dev/null | cut -d: -f2)
    if [[ -n "$domain_ttl" && "$domain_ttl" =~ ^[0-9]+$ ]]; then
      echo "$domain_ttl"
      return 0
    fi
  fi

  # Check for zone-specific TTL
  local zone
  zone=$(get_zone_from_domain "$domain")
  if [[ -n "$zone" ]]; then
    local zone_ttl
    zone_ttl=$(get_zone_ttl "$zone" 2>/dev/null) || true
    if [[ -n "$zone_ttl" && "$zone_ttl" =~ ^[0-9]+$ ]]; then
      echo "$zone_ttl"
      return 0
    fi
  fi

  # Fall back to global TTL
  get_global_ttl
}

# Extract the zone (hosted zone) from a domain name
# For example: api.example.com -> example.com
# This works by finding the zone that would handle this domain in DNS
get_zone_from_domain() {
  local domain="$1"

  # Use awk to reliably extract the last two components
  local zone
  zone=$(echo "$domain" | awk -F. '{
    if (NF >= 2) {
      print $(NF-1) "." $NF
    } else {
      print $0
    }
  }')

  echo "$zone"
}

# Get TTL for a specific zone
get_zone_ttl() {
  local zone="$1"
  local ZONE_TTLS_FILE="$PLUGIN_DATA_ROOT/ZONE_TTLS"

  if [[ -f "$ZONE_TTLS_FILE" ]]; then
    local zone_ttl
    zone_ttl=$(grep "^$zone:" "$ZONE_TTLS_FILE" 2>/dev/null | cut -d: -f2)
    if [[ -n "$zone_ttl" && "$zone_ttl" =~ ^[0-9]+$ ]]; then
      echo "$zone_ttl"
      return 0
    fi
  fi

  # No zone TTL configured
  return 1
}
