#!/usr/bin/env bash
source "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/config"
set -eo pipefail
[[ $DOKKU_TRACE ]] && set -x

if [[ -f "$PLUGIN_CORE_AVAILABLE_PATH/common/functions" ]]; then
  source "$PLUGIN_CORE_AVAILABLE_PATH/common/functions"
fi

if ! declare -f dokku_log_info1 >/dev/null 2>&1; then
  dokku_log_info1() { echo "-----> $*"; }
fi

if ! declare -f dokku_log_info2 >/dev/null 2>&1; then
  dokku_log_info2() { echo "=====> $*"; }
fi

if ! declare -f dokku_log_warn >/dev/null 2>&1; then
  dokku_log_warn() { echo " !     $*"; }
fi

if ! declare -f dokku_log_fail >/dev/null 2>&1; then
  dokku_log_fail() { echo " !     $*" >&2; exit 1; }
fi



get_app_domains() {
  local APP="$1"
  local domains_output
  domains_output=$(dokku domains:report "$APP" --domains-app-vhosts 2>/dev/null || echo "")
  
  if [[ -n "$domains_output" ]]; then
    for domain in $domains_output; do
      echo "$domain"
    done
  fi
}

get_dns_managed_apps() {
  local LINKS_FILE="$PLUGIN_DATA_ROOT/LINKS"
  
  if [[ -f "$LINKS_FILE" ]]; then
    cat "$LINKS_FILE" 2>/dev/null || echo ""
  fi
}

is_app_dns_managed() {
  local APP="$1"
  local LINKS_FILE="$PLUGIN_DATA_ROOT/LINKS"
  
  if [[ -f "$LINKS_FILE" ]] && grep -q "^$APP$" "$LINKS_FILE" 2>/dev/null; then
    return 0
  else
    return 1
  fi
}

zones_set_enabled() {
  local ZONE="$1"
  local ENABLED_ZONES_FILE="$PLUGIN_DATA_ROOT/ENABLED_ZONES"
  
  mkdir -p "$PLUGIN_DATA_ROOT"
  
  if [[ ! -f "$ENABLED_ZONES_FILE" ]] || ! grep -q "^$ZONE$" "$ENABLED_ZONES_FILE"; then
    echo "$ZONE" >> "$ENABLED_ZONES_FILE"
  fi
}

zones_set_disabled() {
  local ZONE="$1"
  local ENABLED_ZONES_FILE="$PLUGIN_DATA_ROOT/ENABLED_ZONES"
  
  if [[ -f "$ENABLED_ZONES_FILE" ]]; then
    local temp_file
    temp_file=$(mktemp)
    grep -v "^$ZONE$" "$ENABLED_ZONES_FILE" > "$temp_file" || true
    
    if [[ ! -s "$temp_file" ]]; then
      rm -f "$ENABLED_ZONES_FILE"
    else
      mv "$temp_file" "$ENABLED_ZONES_FILE"
    fi
    
    rm -f "$temp_file"
  fi
}

is_domain_in_enabled_zone() {
  local DOMAIN="$1"
  local ENABLED_ZONES_FILE="$PLUGIN_DATA_ROOT/ENABLED_ZONES"
  
  if [[ ! -f "$ENABLED_ZONES_FILE" ]]; then
    return 1
  fi
  
  if [[ ! -s "$ENABLED_ZONES_FILE" ]]; then
    return 1
  fi
  
  while IFS= read -r zone; do
    [[ -z "$zone" ]] && continue
    
    if [[ "$DOMAIN" == "$zone" ]] || [[ "$DOMAIN" == *".$zone" ]]; then
      return 0  # Domain is in an enabled zone
    fi
  done < "$ENABLED_ZONES_FILE"
  
  return 1  # Domain not in any enabled zone
}

get_enabled_zones() {
  local ENABLED_ZONES_FILE="$PLUGIN_DATA_ROOT/ENABLED_ZONES"
  
  if [[ -f "$ENABLED_ZONES_FILE" ]]; then
    cat "$ENABLED_ZONES_FILE" 2>/dev/null || echo ""
  fi
}

is_zone_enabled() {
  local ZONE="$1"
  local ENABLED_ZONES_FILE="$PLUGIN_DATA_ROOT/ENABLED_ZONES"
  
  if [[ -f "$ENABLED_ZONES_FILE" ]] && grep -q "^$ZONE$" "$ENABLED_ZONES_FILE" 2>/dev/null; then
    return 0
  else
    return 1
  fi
}


dns_get_record_ip() {
  local DOMAIN="$1"
  
  local PROVIDER_SCRIPT
  PROVIDER_SCRIPT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/providers/aws"
  if [[ -f "$PROVIDER_SCRIPT" ]]; then
    source "$PROVIDER_SCRIPT"
    if declare -f "dns_provider_aws_get_record_ip" >/dev/null 2>&1; then
      local provider_ip
      if provider_ip=$(dns_provider_aws_get_record_ip "$DOMAIN") && [[ -n "$provider_ip" ]]; then
        echo "$provider_ip"
        return 0
      fi
    fi
  fi
  
  local current_ip
  current_ip=$(dig +short "$DOMAIN" A 2>/dev/null | tail -n1 || echo "")
  if [[ -n "$current_ip" ]]; then
    echo "$current_ip"
    return 0
  fi
  
  return 1
}

dns_get_server_ip() {
  local SERVER_IP
  
  local GLOBAL_DOMAINS
  GLOBAL_DOMAINS=$(dokku domains:report --domains-global-vhosts 2>/dev/null || echo "")
  
  if [[ -n "$GLOBAL_DOMAINS" ]]; then
    local FIRST_GLOBAL_DOMAIN
    FIRST_GLOBAL_DOMAIN=$(echo "$GLOBAL_DOMAINS" | head -n1)
    SERVER_IP=$(dig +short "$FIRST_GLOBAL_DOMAIN" | tail -n1 2>/dev/null || echo "")
  fi
  
  if [[ -z "$SERVER_IP" ]]; then
    SERVER_IP=$(curl -s --max-time 3 ifconfig.me 2>/dev/null || curl -s --max-time 3 ipecho.net/plain 2>/dev/null || curl -s --max-time 3 icanhazip.com 2>/dev/null || echo "")
  fi
  
  if [[ -z "$SERVER_IP" ]]; then
    dokku_log_fail "Could not determine server IP. Please ensure your server has internet access or configure global domains."
  fi
  
  echo "$SERVER_IP"
}

dns_app() {
  local APP="$1"
  
  local PROVIDER_SCRIPT
  PROVIDER_SCRIPT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/providers/aws"
  if [[ ! -f "$PROVIDER_SCRIPT" ]]; then
    dokku_log_fail "AWS provider not found at $PROVIDER_SCRIPT"
  fi
  source "$PROVIDER_SCRIPT"
  
  if declare -f "dns_provider_aws_sync_app" >/dev/null 2>&1; then
    dns_provider_aws_sync_app "$APP"
    return 0
  else
    dokku_log_fail "AWS provider does not support sync operations"
  fi
}

dns_add_app_domains() {
  local APP="$1"
  shift
  local DOMAINS=("$@")
  
  if [[ ${#DOMAINS[@]} -eq 0 ]]; then
    local APP_DOMAINS
    APP_DOMAINS=$(dokku domains:report "$APP" --domains-app-vhosts 2>/dev/null || echo "")
    
    if [[ -z "$APP_DOMAINS" ]]; then
      dokku_log_warn "No domains configured for app: $APP"
      dokku_log_info1 "Add domains with: dokku domains:add $APP <domain>"
      return 0
    fi
    
    read -ra DOMAINS <<< "$APP_DOMAINS"
  fi
  
  if [[ ${#DOMAINS[@]} -eq 0 ]]; then
    dokku_log_warn "No domains to add for app: $APP"
    return 0
  fi
  
  
  local APP_DOMAINS_FILE="$PLUGIN_DATA_ROOT/$APP/DOMAINS"
  local ALREADY_ADDED_DOMAINS=()
  local NEW_DOMAINS=()
  
  if [[ -f "$APP_DOMAINS_FILE" ]]; then
    while IFS= read -r domain; do
      [[ -n "$domain" ]] && ALREADY_ADDED_DOMAINS+=("$domain")
    done < "$APP_DOMAINS_FILE"
  fi
  
  for DOMAIN in "${DOMAINS[@]}"; do
    [[ -z "$DOMAIN" ]] && continue
    
    local IS_ALREADY_ADDED=false
    for ADDED_DOMAIN in "${ALREADY_ADDED_DOMAINS[@]}"; do
      if [[ "$DOMAIN" == "$ADDED_DOMAIN" ]]; then
        IS_ALREADY_ADDED=true
        break
      fi
    done
    
    if [[ "$IS_ALREADY_ADDED" == true ]]; then
      continue
    else
      NEW_DOMAINS+=("$DOMAIN")
    fi
  done
  
  if [[ ${#ALREADY_ADDED_DOMAINS[@]} -gt 0 ]]; then
    dokku_log_info1 "Already added domains for app '$APP':"
    for DOMAIN in "${ALREADY_ADDED_DOMAINS[@]}"; do
      local SHOW_DOMAIN=false
      for REQUESTED_DOMAIN in "${DOMAINS[@]}"; do
        if [[ "$DOMAIN" == "$REQUESTED_DOMAIN" ]]; then
          SHOW_DOMAIN=true
          break
        fi
      done
      
      if [[ "$SHOW_DOMAIN" == true ]]; then
        dokku_log_info1 "  ✓ $DOMAIN (already in DNS management)"
      fi
    done
    echo
  fi
  
  if [[ ${#NEW_DOMAINS[@]} -eq 0 ]]; then
    if [[ ${#ALREADY_ADDED_DOMAINS[@]} -gt 0 ]]; then
      dokku_log_info1 "All requested domains are already added to DNS management"
    else
      dokku_log_warn "No domains to add for app: $APP"
    fi
    return 0
  fi
  
  dokku_log_info1 "Processing ${#NEW_DOMAINS[@]} new domain(s) for app '$APP':"
  for domain in "${NEW_DOMAINS[@]}"; do
    dokku_log_info1 "  • $domain"
  done
  echo
  
  local VALID_DOMAINS=()
  local SKIPPED_DOMAINS=()
  
  dokku_log_info1 "Filtering domains - Provider: AWS, New domains: ${#NEW_DOMAINS[@]}"
  
  local PROVIDER_SCRIPT
  PROVIDER_SCRIPT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/providers/aws"
  
  local AWS_AVAILABLE=false
  if command -v aws >/dev/null 2>&1; then
    if aws sts get-caller-identity >/dev/null 2>&1; then
      AWS_AVAILABLE=true
    fi
  fi
  
  if [[ -f "$PROVIDER_SCRIPT" ]] && [[ "$AWS_AVAILABLE" == "true" ]]; then
    source "$PROVIDER_SCRIPT"
    dns_provider_aws_setup_env
      
    dokku_log_info1 "AWS credentials OK - checking hosted zones for new domains..."
    
    for DOMAIN in "${NEW_DOMAINS[@]}"; do
      [[ -z "$DOMAIN" ]] && continue
      
      dokku_log_info1 "Checking domain: $DOMAIN"
      local ZONE_ID
      set +e  # Temporarily disable exit on error
      ZONE_ID=$(dns_provider_aws_get_hosted_zone_id "$DOMAIN" 2>/dev/null)
      local ZONE_CHECK_EXIT_CODE=$?
      set -e  # Re-enable exit on error
      
      if [[ $ZONE_CHECK_EXIT_CODE -eq 0 ]] && [[ -n "$ZONE_ID" ]]; then
        if is_domain_in_enabled_zone "$DOMAIN"; then
          VALID_DOMAINS+=("$DOMAIN")
          dokku_log_info1 "✓ $DOMAIN has hosted zone: $ZONE_ID (zone enabled)"
        else
          SKIPPED_DOMAINS+=("$DOMAIN")
          dokku_log_info1 "✗ $DOMAIN has hosted zone: $ZONE_ID but zone is not enabled for auto-discovery"
        fi
      else
        SKIPPED_DOMAINS+=("$DOMAIN")
        dokku_log_info1 "✗ $DOMAIN has no hosted zone"
      fi
      dokku_log_info1 "Finished checking domain: $DOMAIN"
    done
    dokku_log_info1 "Completed hosted zone checks for all domains"
  else
    if [[ ! -f "$PROVIDER_SCRIPT" ]]; then
      dokku_log_warn "AWS provider script not found - adding all new domains without validation"
    else
      dokku_log_info1 "AWS CLI not available or not configured - adding all new domains without hosted zone validation"
      dokku_log_info1 "Run 'dokku $PLUGIN_COMMAND_PREFIX:providers:verify' to configure AWS credentials for zone validation"
    fi
    VALID_DOMAINS=("${NEW_DOMAINS[@]}")
  fi
  
  if [[ ${#SKIPPED_DOMAINS[@]} -gt 0 ]]; then
    dokku_log_warn "Skipping domains without hosted zones or disabled zones:"
    for DOMAIN in "${SKIPPED_DOMAINS[@]}"; do
      local ZONE_ID
      set +e  # Temporarily disable exit on error
      ZONE_ID=$(dns_provider_aws_get_hosted_zone_id "$DOMAIN" 2>/dev/null)
      local ZONE_EXISTS=$?
      set -e  # Re-enable exit on error
      
      if [[ $ZONE_EXISTS -eq 0 ]] && [[ -n "$ZONE_ID" ]]; then
        dokku_log_info1 "  ❌ $DOMAIN (zone not enabled for auto-discovery)"
      else
        dokku_log_info1 "  ❌ $DOMAIN (no hosted zone found)"
      fi
    done
    echo
  fi
  
  echo
  dns_display_domains_table "$APP" "${NEW_DOMAINS[@]}"
  
  if [[ ${#VALID_DOMAINS[@]} -eq 0 ]]; then
    dokku_log_warn "No domains with enabled hosted zones found for app: $APP"
    if [[ ${#SKIPPED_DOMAINS[@]} -gt 0 ]]; then
      dokku_log_info1 "Enable zones for auto-discovery with: dokku $PLUGIN_COMMAND_PREFIX:zones:enable <zone>"
      dokku_log_info1 "Or create hosted zones for these domains in your DNS provider first"
    fi
    return 0
  fi
  
  dokku_log_info2 "Adding domains for app '$APP' to DNS (${#VALID_DOMAINS[@]} domains)"
  
  local LINKS_FILE="$PLUGIN_DATA_ROOT/LINKS"
  mkdir -p "$PLUGIN_DATA_ROOT"
  mkdir -p "$PLUGIN_DATA_ROOT/$APP"
  
  if [[ ! -f "$LINKS_FILE" ]] || ! grep -q "^$APP$" "$LINKS_FILE" 2>/dev/null; then
    echo "$APP" >> "$LINKS_FILE"
    dokku_log_info1 "App '$APP' added to DNS"
  else
    dokku_log_info1 "App '$APP' already in DNS, adding new domains"
  fi
  
  for DOMAIN in "${VALID_DOMAINS[@]}"; do
    echo "$DOMAIN" >> "$APP_DOMAINS_FILE"
  done
  
  if [[ -f "$APP_DOMAINS_FILE" ]]; then
    sort -u "$APP_DOMAINS_FILE" > "${APP_DOMAINS_FILE}.tmp"
    mv "${APP_DOMAINS_FILE}.tmp" "$APP_DOMAINS_FILE"
  fi
  
  dokku_log_info1 "${#VALID_DOMAINS[@]} domain(s) with hosted zones have been added to DNS"
  dokku_log_info1 "Next step: dokku $PLUGIN_COMMAND_PREFIX:apps:sync $APP"
}

dns_remove_app() {
  local APP="$1"
  local LINKS_FILE="$PLUGIN_DATA_ROOT/LINKS"
  
  dokku_log_info2 "Removing app '$APP' from DNS"
  
  if [[ ! -f "$LINKS_FILE" ]]; then
    dokku_log_warn "No DNS tracking file found"
    return 0
  fi
  
  if grep -q "^$APP$" "$LINKS_FILE" 2>/dev/null; then
    grep -v "^$APP$" "$LINKS_FILE" > "${LINKS_FILE}.tmp" || true
    mv "${LINKS_FILE}.tmp" "$LINKS_FILE"
    
    local APP_DOMAINS_FILE="$PLUGIN_DATA_ROOT/$APP/DOMAINS"
    if [[ -f "$APP_DOMAINS_FILE" ]]; then
      rm -f "$APP_DOMAINS_FILE"
    fi
    
    if [[ -d "$PLUGIN_DATA_ROOT/$APP" ]]; then
      rmdir "$PLUGIN_DATA_ROOT/$APP" 2>/dev/null || true
    fi
    
    dokku_log_info1 "App '$APP' removed from DNS"
    dokku_log_info1 "Note: Existing DNS records were not deleted"
    dokku_log_info1 "To clean up DNS records, run: dokku $PLUGIN_COMMAND_PREFIX:apps:sync $APP (before removing next time)"
  else
    dokku_log_warn "App '$APP' was not found in DNS tracking"
  fi
  
  if [[ ! -s "$LINKS_FILE" ]]; then
    rm -f "$LINKS_FILE"
    dokku_log_info1 "No apps remaining in DNS - tracking file cleaned up"
  fi
}

dns_display_domains_table() {
  local APP="$1"
  shift
  local DOMAINS=("$@")
  
  local SERVER_IP
  SERVER_IP=$(dns_get_server_ip)
  
  local SYNC_STATUS="Not configured"
  local CREDENTIALS_DIR="$PLUGIN_DATA_ROOT/credentials"
  
  if [[ -d "$CREDENTIALS_DIR" ]] && [[ -f "$CREDENTIALS_DIR/AWS_ACCESS_KEY_ID" ]]; then
    SYNC_STATUS="Ready"
  elif aws sts get-caller-identity >/dev/null 2>&1; then
    SYNC_STATUS="Ready"
  else
    SYNC_STATUS="Missing auth"
  fi
  
  if [[ "$SYNC_STATUS" == "Ready" ]]; then
    local PROVIDER_SCRIPT
    PROVIDER_SCRIPT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/providers/aws"
    if [[ -f "$PROVIDER_SCRIPT" ]]; then
      source "$PROVIDER_SCRIPT"
      dns_provider_aws_setup_env
    fi
  fi
  
  echo
  dokku_log_info2 "Domain Status Table for app '$APP':"
  printf "%-30s %-8s %-15s %-15s %s\n" "Domain" "Status" "Enabled" "Provider" "Zone (Enabled)"
  printf "%-30s %-8s %-15s %-15s %s\n" "------" "------" "-------" "--------" "---------------"
  
  for DOMAIN in "${DOMAINS[@]}"; do
    [[ -z "$DOMAIN" ]] && continue
    
    local CURRENT_IP
    CURRENT_IP=$(dns_get_record_ip "$DOMAIN" || echo "")
    
    local DNS_EMOJI="❌"
    if [[ -n "$CURRENT_IP" ]]; then
      if [[ "$CURRENT_IP" == "$SERVER_IP" ]]; then
        DNS_EMOJI="✅"
      else
        DNS_EMOJI="⚠️"
      fi
    fi
    
    local HOSTED_ZONE="-"
    local ZONE_ID=""
    if [[ "$SYNC_STATUS" == "Ready" ]]; then
      if declare -f "dns_provider_aws_get_hosted_zone_id" >/dev/null 2>&1; then
        ZONE_ID=$(dns_provider_aws_get_hosted_zone_id "$DOMAIN" 2>/dev/null || echo "")
        if [[ -n "$ZONE_ID" ]]; then
          local ZONE_NAME
          ZONE_NAME=$(aws route53 get-hosted-zone --id "$ZONE_ID" --query 'HostedZone.Name' --output text 2>/dev/null | sed 's/\.$//g' || echo "$ZONE_ID")
          if is_zone_enabled "$ZONE_NAME"; then
            HOSTED_ZONE="$ZONE_NAME ✅"
          else
            HOSTED_ZONE="$ZONE_NAME ❌"
          fi
        else
          HOSTED_ZONE="Not found"
        fi
      fi
    fi
    
    local ENABLED_STATUS="No"
    if [[ "$SYNC_STATUS" == "Ready" ]]; then
      if [[ -n "$ZONE_ID" ]]; then
        if is_domain_in_enabled_zone "$DOMAIN"; then
          ENABLED_STATUS="Yes"
        else
          ENABLED_STATUS="No (zone disabled)"
        fi
      else
        ENABLED_STATUS="No (no hosted zone)"
      fi
    else
      ENABLED_STATUS="No (provider not ready)"
    fi
    
    printf "%-30s %-8s %-15s %-15s %s\n" "$DOMAIN" "$DNS_EMOJI" "$ENABLED_STATUS" "AWS" "$HOSTED_ZONE"
  done
  
  echo
  dokku_log_info2 "Status Legend:"
  if [[ -n "$SERVER_IP" ]] && [[ "$SERVER_IP" != "Unknown" ]]; then
    dokku_log_info1 "✅ Points to server IP ($SERVER_IP)"
    dokku_log_info1 "⚠️  Points to different IP"
  else
    dokku_log_info1 "❓ Server IP unknown - cannot validate"
  fi
  dokku_log_info1 "❌ No DNS record found"
}

get_server_ip() {
  local SERVER_IP=""
  local GLOBAL_DOMAINS=""
  
  if command -v dokku >/dev/null 2>&1; then
    GLOBAL_DOMAINS=$(dokku domains:report --domains-global-vhosts 2>/dev/null || echo "")
  fi
  
  if [[ -n "$GLOBAL_DOMAINS" ]] && command -v dig >/dev/null 2>&1; then
    local FIRST_GLOBAL_DOMAIN
    FIRST_GLOBAL_DOMAIN=$(echo "$GLOBAL_DOMAINS" | head -n1)
    local RESOLVED_IP
    RESOLVED_IP=$(dig +short "$FIRST_GLOBAL_DOMAIN" 2>/dev/null | tail -n1 || echo "")
    if [[ -n "$RESOLVED_IP" ]] && [[ "$RESOLVED_IP" != "127.0.0.1" ]]; then
      SERVER_IP="$RESOLVED_IP"
    fi
  fi
  
  if [[ -z "$SERVER_IP" ]] && command -v curl >/dev/null 2>&1; then
    local PUBLIC_IP
    PUBLIC_IP=$(curl -s --max-time 3 ifconfig.me 2>/dev/null || curl -s --max-time 3 ipecho.net/plain 2>/dev/null || curl -s --max-time 3 icanhazip.com 2>/dev/null || echo "")
    if [[ -n "$PUBLIC_IP" ]] && [[ "$PUBLIC_IP" != "127.0.0.1" ]]; then
      SERVER_IP="$PUBLIC_IP"
    fi
  fi
  
  if [[ -z "$SERVER_IP" ]]; then
    SERVER_IP="Unknown"
  fi
  
  echo "$SERVER_IP"
}

domain_points_to_server() {
  local DOMAIN="$1"
  local SERVER_IP
  SERVER_IP=$(get_server_ip)
  
  if [[ -z "$SERVER_IP" ]] || [[ "$SERVER_IP" == "Unknown" ]]; then
    return 1
  fi
  
  if command -v dig >/dev/null 2>&1; then
    local CURRENT_IP
    CURRENT_IP=$(dig +short "$DOMAIN" A 2>/dev/null | tail -n1 || echo "")
    if [[ -n "$CURRENT_IP" ]] && [[ "$CURRENT_IP" == "$SERVER_IP" ]]; then
      return 0
    fi
  fi
  
  return 1
}

dns_domain_matches_managed_zone() {
  local DOMAIN="$1"
  
  local LINKS_FILE="$PLUGIN_DATA_ROOT/LINKS"
  if [[ ! -f "$LINKS_FILE" ]] || [[ ! -s "$LINKS_FILE" ]]; then
    return 1
  fi
  
  local all_managed_domains=()
  while IFS= read -r app; do
    [[ -z "$app" ]] && continue
    local APP_DOMAINS_FILE="$PLUGIN_DATA_ROOT/$app/DOMAINS"
    if [[ -f "$APP_DOMAINS_FILE" ]]; then
      while IFS= read -r domain; do
        [[ -n "$domain" ]] && all_managed_domains+=("$domain")
      done < "$APP_DOMAINS_FILE"
    fi
  done < "$LINKS_FILE"
  
  if [[ ${#all_managed_domains[@]} -eq 0 ]]; then
    return 1
  fi
  
  local domain_zone
  domain_zone=$(extract_root_domain "$DOMAIN")
  
  for managed_domain in "${all_managed_domains[@]}"; do
    local managed_zone
    managed_zone=$(extract_root_domain "$managed_domain")
    if [[ "$domain_zone" == "$managed_zone" ]]; then
      return 0
    fi
  done
  
  return 1
}

extract_root_domain() {
  local DOMAIN="$1"
  
  local part_count
  part_count=$(echo "$DOMAIN" | tr '.' '\n' | wc -l)
  
  if [[ $part_count -le 2 ]]; then
    echo "$DOMAIN"
    return 0
  fi
  
  echo "$DOMAIN" | awk -F. '{print $(NF-1)"."$NF}'
}

dns_plan_changes() {
  local APP="$1"
  local PROVIDER="${2:-aws}"
  
  local ADD_COUNT=0
  local CHANGE_COUNT=0
  local NO_CHANGE_COUNT=0
  
  local SERVER_IP
  SERVER_IP=$(get_server_ip)
  
  if [[ -z "$SERVER_IP" ]] || [[ "$SERVER_IP" == "Unknown" ]]; then
    echo "ERROR: Unable to determine server IP address"
    return 1
  fi
  
  local APP_DOMAINS_FILE="$PLUGIN_DATA_ROOT/$APP/DOMAINS"
  local APP_DOMAINS=""
  
  if [[ -f "$APP_DOMAINS_FILE" ]]; then
    APP_DOMAINS=$(tr '\n' ' ' < "$APP_DOMAINS_FILE" 2>/dev/null)
  fi
  
  if [[ -z "$APP_DOMAINS" ]]; then
    echo "ADD_COUNT:0"
    echo "CHANGE_COUNT:0"
    echo "NO_CHANGE_COUNT:0"
    echo "TOTAL_COUNT:0"
    echo "ERROR:No DNS-managed domains found for app: $APP"
    return 0
  fi
  
  local PROVIDER_SCRIPT
  PROVIDER_SCRIPT="$(dirname "${BASH_SOURCE[0]}")/providers/$PROVIDER"
  if [[ -f "$PROVIDER_SCRIPT" ]]; then
    source "$PROVIDER_SCRIPT"
    if [[ "$PROVIDER" == "aws" ]]; then
      dns_provider_aws_setup_env
    fi
  fi
  
  for DOMAIN in $APP_DOMAINS; do
    [[ -z "$DOMAIN" ]] && continue
    
    local CURRENT_IP=""
    if declare -f "dns_provider_${PROVIDER}_get_record_ip" >/dev/null 2>&1; then
      CURRENT_IP=$(dns_provider_"${PROVIDER}"_get_record_ip "$DOMAIN" 2>/dev/null || echo "")
    fi
    
    local ZONE_ID=""
    if declare -f "dns_provider_${PROVIDER}_get_hosted_zone_id" >/dev/null 2>&1; then
      ZONE_ID=$(dns_provider_"${PROVIDER}"_get_hosted_zone_id "$DOMAIN" 2>/dev/null || echo "")
    fi
    
    if [[ -z "$ZONE_ID" ]]; then
      echo "ERROR_DOMAIN:$DOMAIN:No hosted zone found"
      continue
    fi
    
    if [[ -z "$CURRENT_IP" ]]; then
      echo "ADD:$DOMAIN:$SERVER_IP"
      ADD_COUNT=$((ADD_COUNT + 1))
    elif [[ "$CURRENT_IP" != "$SERVER_IP" ]]; then
      echo "CHANGE:$DOMAIN:$SERVER_IP:$CURRENT_IP"
      CHANGE_COUNT=$((CHANGE_COUNT + 1))
    else
      echo "NO_CHANGE:$DOMAIN:$SERVER_IP"
      NO_CHANGE_COUNT=$((NO_CHANGE_COUNT + 1))
    fi
  done
  
  local TOTAL_COUNT=$((ADD_COUNT + CHANGE_COUNT + NO_CHANGE_COUNT))
  echo "ADD_COUNT:$ADD_COUNT"
  echo "CHANGE_COUNT:$CHANGE_COUNT"
  echo "NO_CHANGE_COUNT:$NO_CHANGE_COUNT"
  echo "TOTAL_COUNT:$TOTAL_COUNT"
}
