#!/usr/bin/env bash
# DNS Plugin Functions
source "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/config"
set -eo pipefail
[[ $DOKKU_TRACE ]] && set -x

# Load dokku functions if available
if [[ -f "$PLUGIN_CORE_AVAILABLE_PATH/common/functions" ]]; then
  source "$PLUGIN_CORE_AVAILABLE_PATH/common/functions"
fi

# Define missing functions if needed
if ! declare -f dokku_log_info1 >/dev/null 2>&1; then
  dokku_log_info1() { echo "-----> $*"; }
fi

if ! declare -f dokku_log_info2 >/dev/null 2>&1; then
  dokku_log_info2() { echo "=====> $*"; }
fi

if ! declare -f dokku_log_warn >/dev/null 2>&1; then
  dokku_log_warn() { echo " !     $*"; }
fi

if ! declare -f dokku_log_fail >/dev/null 2>&1; then
  dokku_log_fail() { echo " !     $*" >&2; exit 1; }
fi

# DNS-specific functions
# These functions are available to other plugins that source this file

# Public API Functions (safe for other plugins to use)

# Get all domains configured for a specific app
# Usage: get_app_domains <app>
# Returns: newline-separated list of domains
get_app_domains() {
  local APP="$1"
  local domains_output
  # Use dokku domains:report to get app domains
  # Note: This is acceptable as it's using the domains plugin API correctly
  domains_output=$(dokku domains:report "$APP" --domains-app-vhosts 2>/dev/null || echo "")
  
  # Convert space-separated domains to newline-separated for proper array processing
  if [[ -n "$domains_output" ]]; then
    for domain in $domains_output; do
      echo "$domain"
    done
  fi
}

# Get list of all apps currently managed by DNS plugin
# Usage: get_dns_managed_apps
# Returns: newline-separated list of app names
get_dns_managed_apps() {
  local LINKS_FILE="$PLUGIN_DATA_ROOT/LINKS"
  
  if [[ -f "$LINKS_FILE" ]]; then
    cat "$LINKS_FILE" 2>/dev/null || echo ""
  fi
}

# Check if an app is currently managed by DNS plugin
# Usage: is_app_dns_managed <app>
# Returns: 0 if managed, 1 if not managed
is_app_dns_managed() {
  local APP="$1"
  local LINKS_FILE="$PLUGIN_DATA_ROOT/LINKS"
  
  if [[ -f "$LINKS_FILE" ]] && grep -q "^$APP$" "$LINKS_FILE" 2>/dev/null; then
    return 0
  else
    return 1
  fi
}

# Zone management functions
zones_set_enabled() {
  local ZONE="$1"
  local ENABLED_ZONES_FILE="$PLUGIN_DATA_ROOT/ENABLED_ZONES"
  
  mkdir -p "$PLUGIN_DATA_ROOT"
  
  # Add zone to enabled zones if not already present
  if [[ ! -f "$ENABLED_ZONES_FILE" ]] || ! grep -q "^$ZONE$" "$ENABLED_ZONES_FILE"; then
    echo "$ZONE" >> "$ENABLED_ZONES_FILE"
  fi
}

zones_set_disabled() {
  local ZONE="$1"
  local ENABLED_ZONES_FILE="$PLUGIN_DATA_ROOT/ENABLED_ZONES"
  
  if [[ -f "$ENABLED_ZONES_FILE" ]]; then
    # Remove the zone from enabled zones file
    local temp_file
    temp_file=$(mktemp)
    grep -v "^$ZONE$" "$ENABLED_ZONES_FILE" > "$temp_file" || true
    
    # If file is empty after removal, delete it
    if [[ ! -s "$temp_file" ]]; then
      rm -f "$ENABLED_ZONES_FILE"
    else
      mv "$temp_file" "$ENABLED_ZONES_FILE"
    fi
    
    rm -f "$temp_file"
  fi
}

# Check if a domain is in an enabled hosted zone
# Usage: is_domain_in_enabled_zone <domain>
# Returns: 0 if domain is in enabled zone, 1 if not
is_domain_in_enabled_zone() {
  local DOMAIN="$1"
  local ENABLED_ZONES_FILE="$PLUGIN_DATA_ROOT/ENABLED_ZONES"
  
  # If no enabled zones file exists, return false (no zones enabled)
  if [[ ! -f "$ENABLED_ZONES_FILE" ]]; then
    return 1
  fi
  
  # If file exists but is empty, no zones are enabled
  if [[ ! -s "$ENABLED_ZONES_FILE" ]]; then
    return 1
  fi
  
  # Check if domain matches any enabled zone
  while IFS= read -r zone; do
    [[ -z "$zone" ]] && continue
    
    # Check if domain matches this zone exactly or is a subdomain
    if [[ "$DOMAIN" == "$zone" ]] || [[ "$DOMAIN" == *".$zone" ]]; then
      return 0  # Domain is in an enabled zone
    fi
  done < "$ENABLED_ZONES_FILE"
  
  return 1  # Domain not in any enabled zone
}

# Get list of enabled zones
# Usage: get_enabled_zones
# Returns: newline-separated list of enabled zone names
get_enabled_zones() {
  local ENABLED_ZONES_FILE="$PLUGIN_DATA_ROOT/ENABLED_ZONES"
  
  if [[ -f "$ENABLED_ZONES_FILE" ]]; then
    cat "$ENABLED_ZONES_FILE" 2>/dev/null || echo ""
  fi
}

# Check if a zone is enabled
# Usage: is_zone_enabled <zone>
# Returns: 0 if zone is enabled, 1 if not
is_zone_enabled() {
  local ZONE="$1"
  local ENABLED_ZONES_FILE="$PLUGIN_DATA_ROOT/ENABLED_ZONES"
  
  if [[ -f "$ENABLED_ZONES_FILE" ]] && grep -q "^$ZONE$" "$ENABLED_ZONES_FILE" 2>/dev/null; then
    return 0
  else
    return 1
  fi
}


dns_get_record_ip() {
  local DOMAIN="$1"
  
  # Try AWS provider DNS checking first (bypasses DNS caching)
  local PROVIDER_SCRIPT
  PROVIDER_SCRIPT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/providers/aws.sh"
  if [[ -f "$PROVIDER_SCRIPT" ]]; then
    source "$PROVIDER_SCRIPT"
    if declare -f "dns_provider_aws_get_record_ip" >/dev/null 2>&1; then
      local provider_ip
      if provider_ip=$(dns_provider_aws_get_record_ip "$DOMAIN") && [[ -n "$provider_ip" ]]; then
        echo "$provider_ip"
        return 0
      fi
    fi
  fi
  
  # Fallback to DNS resolution (may be cached)
  local current_ip
  current_ip=$(dig +short "$DOMAIN" A 2>/dev/null | tail -n1 || echo "")
  if [[ -n "$current_ip" ]]; then
    echo "$current_ip"
    return 0
  fi
  
  return 1
}

dns_get_server_ip() {
  # Try to get the server's public IP using multiple methods
  local SERVER_IP
  
  # First try to use global domains to resolve server IP
  local GLOBAL_DOMAINS
  # Use dokku domains:report to get global domains
  # Note: This is acceptable as it's using the domains plugin API correctly
  GLOBAL_DOMAINS=$(dokku domains:report --domains-global-vhosts 2>/dev/null || echo "")
  
  if [[ -n "$GLOBAL_DOMAINS" ]]; then
    # Use the first global domain to resolve server IP
    local FIRST_GLOBAL_DOMAIN
    FIRST_GLOBAL_DOMAIN=$(echo "$GLOBAL_DOMAINS" | head -n1)
    SERVER_IP=$(dig +short "$FIRST_GLOBAL_DOMAIN" | tail -n1 2>/dev/null || echo "")
  fi
  
  # If no global domains or couldn't resolve, try to get server IP another way
  if [[ -z "$SERVER_IP" ]]; then
    # Try to get the server's public IP
    SERVER_IP=$(curl -s --max-time 3 ifconfig.me 2>/dev/null || curl -s --max-time 3 ipecho.net/plain 2>/dev/null || curl -s --max-time 3 icanhazip.com 2>/dev/null || echo "")
  fi
  
  if [[ -z "$SERVER_IP" ]]; then
    dokku_log_fail "Could not determine server IP. Please ensure your server has internet access or configure global domains."
  fi
  
  echo "$SERVER_IP"
}

dns_app() {
  local APP="$1"
  
  # Load AWS provider functions (includes generic interface)
  local PROVIDER_SCRIPT
  PROVIDER_SCRIPT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/providers/aws.sh"
  if [[ ! -f "$PROVIDER_SCRIPT" ]]; then
    dokku_log_fail "AWS provider not found at $PROVIDER_SCRIPT"
  fi
  source "$PROVIDER_SCRIPT"
  
  # Call the AWS sync function (which uses the new adapter system internally)
  if declare -f "dns_provider_aws_sync_app" >/dev/null 2>&1; then
    dns_provider_aws_sync_app "$APP"
    return 0
  else
    dokku_log_fail "AWS provider does not support sync operations"
  fi
}

dns_add_app_domains() {
  local APP="$1"
  shift
  local DOMAINS=("$@")
  
  # If no domains specified, get all domains for the app
  if [[ ${#DOMAINS[@]} -eq 0 ]]; then
    local APP_DOMAINS
    # Use dokku domains:report to get app domains
    # Note: This is acceptable as it's using the domains plugin API correctly
    APP_DOMAINS=$(dokku domains:report "$APP" --domains-app-vhosts 2>/dev/null || echo "")
    
    if [[ -z "$APP_DOMAINS" ]]; then
      dokku_log_warn "No domains configured for app: $APP"
      dokku_log_info1 "Add domains with: dokku domains:add $APP <domain>"
      return 0
    fi
    
    # Convert space-separated domains to array
    read -ra DOMAINS <<< "$APP_DOMAINS"
  fi
  
  if [[ ${#DOMAINS[@]} -eq 0 ]]; then
    dokku_log_warn "No domains to add for app: $APP"
    return 0
  fi
  
  
  # Check which domains are already added to DNS for this app
  local APP_DOMAINS_FILE="$PLUGIN_DATA_ROOT/$APP/DOMAINS"
  local ALREADY_ADDED_DOMAINS=()
  local NEW_DOMAINS=()
  
  # Get list of already added domains for this app
  if [[ -f "$APP_DOMAINS_FILE" ]]; then
    while IFS= read -r domain; do
      [[ -n "$domain" ]] && ALREADY_ADDED_DOMAINS+=("$domain")
    done < "$APP_DOMAINS_FILE"
  fi
  
  # Separate already-added domains from new domains
  for DOMAIN in "${DOMAINS[@]}"; do
    [[ -z "$DOMAIN" ]] && continue
    
    local IS_ALREADY_ADDED=false
    for ADDED_DOMAIN in "${ALREADY_ADDED_DOMAINS[@]}"; do
      if [[ "$DOMAIN" == "$ADDED_DOMAIN" ]]; then
        IS_ALREADY_ADDED=true
        break
      fi
    done
    
    if [[ "$IS_ALREADY_ADDED" == true ]]; then
      # Domain is already added, don't process it again
      continue
    else
      NEW_DOMAINS+=("$DOMAIN")
    fi
  done
  
  # Show status of already-added domains
  if [[ ${#ALREADY_ADDED_DOMAINS[@]} -gt 0 ]]; then
    dokku_log_info1 "Already added domains for app '$APP':"
    for DOMAIN in "${ALREADY_ADDED_DOMAINS[@]}"; do
      # Only show if it's in the current request
      local SHOW_DOMAIN=false
      for REQUESTED_DOMAIN in "${DOMAINS[@]}"; do
        if [[ "$DOMAIN" == "$REQUESTED_DOMAIN" ]]; then
          SHOW_DOMAIN=true
          break
        fi
      done
      
      if [[ "$SHOW_DOMAIN" == true ]]; then
        dokku_log_info1 "  ✓ $DOMAIN (already in DNS management)"
      fi
    done
    echo
  fi
  
  # If no new domains to add, show message and exit
  if [[ ${#NEW_DOMAINS[@]} -eq 0 ]]; then
    if [[ ${#ALREADY_ADDED_DOMAINS[@]} -gt 0 ]]; then
      dokku_log_info1 "All requested domains are already added to DNS management"
    else
      dokku_log_warn "No domains to add for app: $APP"
    fi
    return 0
  fi
  
  dokku_log_info1 "Processing ${#NEW_DOMAINS[@]} new domain(s) for app '$APP':"
  for domain in "${NEW_DOMAINS[@]}"; do
    dokku_log_info1 "  • $domain"
  done
  echo
  
  # Filter new domains to only include those with hosted zones
  local VALID_DOMAINS=()
  local SKIPPED_DOMAINS=()
  
  dokku_log_info1 "Filtering domains - Using provider system, New domains: ${#NEW_DOMAINS[@]}"
  
  # Load generic provider interface
  local PROVIDER_SCRIPT
  PROVIDER_SCRIPT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/providers/aws.sh"
  
  # Check if any provider is available and configured
  local PROVIDER_AVAILABLE=false
  if [[ -f "$PROVIDER_SCRIPT" ]]; then
    source "$PROVIDER_SCRIPT"
    # Try to initialize provider system to check availability
    if provider_validate_domain "test.example.com" >/dev/null 2>&1 || [[ $? -eq 1 ]]; then
      PROVIDER_AVAILABLE=true
    fi
  fi
  
  if [[ -f "$PROVIDER_SCRIPT" ]] && [[ "$PROVIDER_AVAILABLE" == "true" ]]; then
    # Provider system is available - check zones for domain validation
    dokku_log_info1 "Provider system ready - checking zones for new domains..."
    
    for DOMAIN in "${NEW_DOMAINS[@]}"; do
      [[ -z "$DOMAIN" ]] && continue
      
      dokku_log_info1 "Checking domain: $DOMAIN"
      # Check if domain can be managed by any provider
      if provider_validate_domain "$DOMAIN"; then
        # Check if this domain is in an enabled zone
        if is_domain_in_enabled_zone "$DOMAIN"; then
          VALID_DOMAINS+=("$DOMAIN")
          dokku_log_info1 "✓ $DOMAIN can be managed (zone enabled)"
        else
          SKIPPED_DOMAINS+=("$DOMAIN")
          dokku_log_info1 "✗ $DOMAIN can be managed but zone is not enabled for auto-discovery"
        fi
      else
        SKIPPED_DOMAINS+=("$DOMAIN")
        dokku_log_info1 "✗ $DOMAIN cannot be managed (no provider zone found)"
      fi
      dokku_log_info1 "Finished checking domain: $DOMAIN"
    done
    dokku_log_info1 "Completed zone checks for all domains"
  else
    # Provider system not available/configured or provider script missing - skip validation
    if [[ ! -f "$PROVIDER_SCRIPT" ]]; then
      dokku_log_warn "Provider script not found - adding all new domains without validation"
    else
      dokku_log_info1 "Provider system not available or not configured - adding all new domains without zone validation"
      dokku_log_info1 "Run 'dokku $PLUGIN_COMMAND_PREFIX:providers:verify' to configure provider credentials for zone validation"
    fi
    VALID_DOMAINS=("${NEW_DOMAINS[@]}")
  fi
  
  # Report skipped domains
  if [[ ${#SKIPPED_DOMAINS[@]} -gt 0 ]]; then
    dokku_log_warn "Skipping domains without hosted zones or disabled zones:"
    for DOMAIN in "${SKIPPED_DOMAINS[@]}"; do
      # Check if it was skipped due to zone being disabled vs no hosted zone
      local ZONE_ID
      set +e  # Temporarily disable exit on error
      ZONE_ID=$(dns_provider_aws_get_hosted_zone_id "$DOMAIN" 2>/dev/null)
      local ZONE_EXISTS=$?
      set -e  # Re-enable exit on error
      
      if [[ $ZONE_EXISTS -eq 0 ]] && [[ -n "$ZONE_ID" ]]; then
        dokku_log_info1 "  ❌ $DOMAIN (zone not enabled for auto-discovery)"
      else
        dokku_log_info1 "  ❌ $DOMAIN (no hosted zone found)"
      fi
    done
    echo
  fi
  
  # Always show status table for all requested domains
  echo
  dns_display_domains_table "$APP" "${NEW_DOMAINS[@]}"
  
  # Check if we have any valid domains left
  if [[ ${#VALID_DOMAINS[@]} -eq 0 ]]; then
    dokku_log_warn "No domains with enabled hosted zones found for app: $APP"
    if [[ ${#SKIPPED_DOMAINS[@]} -gt 0 ]]; then
      dokku_log_info1 "Enable zones for auto-discovery with: dokku $PLUGIN_COMMAND_PREFIX:zones:enable <zone>"
      dokku_log_info1 "Or create hosted zones for these domains in your DNS provider first"
    fi
    return 0
  fi
  
  dokku_log_info2 "Adding domains for app '$APP' to DNS (${#VALID_DOMAINS[@]} domains)"
  
  # Track this app as being added to DNS
  local LINKS_FILE="$PLUGIN_DATA_ROOT/LINKS"
  mkdir -p "$PLUGIN_DATA_ROOT"
  mkdir -p "$PLUGIN_DATA_ROOT/$APP"
  
  # Add app to LINKS file if not already present
  if [[ ! -f "$LINKS_FILE" ]] || ! grep -q "^$APP$" "$LINKS_FILE" 2>/dev/null; then
    echo "$APP" >> "$LINKS_FILE"
    dokku_log_info1 "App '$APP' added to DNS"
  else
    dokku_log_info1 "App '$APP' already in DNS, adding new domains"
  fi
  
  # Add valid domains to the app's domains file
  for DOMAIN in "${VALID_DOMAINS[@]}"; do
    echo "$DOMAIN" >> "$APP_DOMAINS_FILE"
  done
  
  # Remove duplicates from the domains file
  if [[ -f "$APP_DOMAINS_FILE" ]]; then
    sort -u "$APP_DOMAINS_FILE" > "${APP_DOMAINS_FILE}.tmp"
    mv "${APP_DOMAINS_FILE}.tmp" "$APP_DOMAINS_FILE"
  fi
  
  dokku_log_info1 "${#VALID_DOMAINS[@]} domain(s) with hosted zones have been added to DNS"
  dokku_log_info1 "Next step: dokku $PLUGIN_COMMAND_PREFIX:apps:sync $APP"
}

dns_remove_app() {
  local APP="$1"
  local LINKS_FILE="$PLUGIN_DATA_ROOT/LINKS"
  
  dokku_log_info2 "Removing app '$APP' from DNS"
  
  # Check if LINKS file exists
  if [[ ! -f "$LINKS_FILE" ]]; then
    dokku_log_warn "No DNS tracking file found"
    return 0
  fi
  
  # Remove app from LINKS file
  if grep -q "^$APP$" "$LINKS_FILE" 2>/dev/null; then
    # Create a temporary file without this app
    grep -v "^$APP$" "$LINKS_FILE" > "${LINKS_FILE}.tmp" || true
    mv "${LINKS_FILE}.tmp" "$LINKS_FILE"
    
    # Remove the app's domains file
    local APP_DOMAINS_FILE="$PLUGIN_DATA_ROOT/$APP/DOMAINS"
    if [[ -f "$APP_DOMAINS_FILE" ]]; then
      rm -f "$APP_DOMAINS_FILE"
    fi
    
    # Remove the app directory if it's empty
    if [[ -d "$PLUGIN_DATA_ROOT/$APP" ]]; then
      rmdir "$PLUGIN_DATA_ROOT/$APP" 2>/dev/null || true
    fi
    
    dokku_log_info1 "App '$APP' removed from DNS"
    dokku_log_info1 "Note: Existing DNS records were not deleted"
    dokku_log_info1 "To clean up DNS records, run: dokku $PLUGIN_COMMAND_PREFIX:apps:sync $APP (before removing next time)"
  else
    dokku_log_warn "App '$APP' was not found in DNS tracking"
  fi
  
  # Clean up empty LINKS file
  if [[ ! -s "$LINKS_FILE" ]]; then
    rm -f "$LINKS_FILE"
    dokku_log_info1 "No apps remaining in DNS - tracking file cleaned up"
  fi
}

dns_display_domains_table() {
  local APP="$1"
  shift
  local DOMAINS=("$@")
  
  # Get server IP
  local SERVER_IP
  SERVER_IP=$(dns_get_server_ip)
  
  # Check AWS provider status
  local SYNC_STATUS="Not configured"
  local CREDENTIALS_DIR="$PLUGIN_DATA_ROOT/credentials"
  
  if [[ -d "$CREDENTIALS_DIR" ]] && [[ -f "$CREDENTIALS_DIR/AWS_ACCESS_KEY_ID" ]]; then
    SYNC_STATUS="Ready"
  elif aws sts get-caller-identity >/dev/null 2>&1; then
    SYNC_STATUS="Ready"
  else
    SYNC_STATUS="Missing auth"
  fi
  
  # Load AWS provider functions if available
  if [[ "$SYNC_STATUS" == "Ready" ]]; then
    local PROVIDER_SCRIPT
    PROVIDER_SCRIPT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/providers/aws.sh"
    if [[ -f "$PROVIDER_SCRIPT" ]]; then
      source "$PROVIDER_SCRIPT"
      dns_provider_aws_setup_env
    fi
  fi
  
  echo
  dokku_log_info2 "Domain Status Table for app '$APP':"
  printf "%-30s %-8s %-15s %-15s %s\n" "Domain" "Status" "Enabled" "Provider" "Zone (Enabled)"
  printf "%-30s %-8s %-15s %-15s %s\n" "------" "------" "-------" "--------" "---------------"
  
  for DOMAIN in "${DOMAINS[@]}"; do
    [[ -z "$DOMAIN" ]] && continue
    
    # Get current DNS resolution (using provider-specific checking if available)
    local CURRENT_IP
    CURRENT_IP=$(dns_get_record_ip "$DOMAIN" || echo "")
    
    # Determine DNS status emoji
    local DNS_EMOJI="❌"
    if [[ -n "$CURRENT_IP" ]]; then
      if [[ "$CURRENT_IP" == "$SERVER_IP" ]]; then
        DNS_EMOJI="✅"
      else
        DNS_EMOJI="⚠️"
      fi
    fi
    
    # Try to get hosted zone if AWS is ready
    local HOSTED_ZONE="-"
    local ZONE_ID=""
    if [[ "$SYNC_STATUS" == "Ready" ]]; then
      if declare -f "dns_provider_aws_get_hosted_zone_id" >/dev/null 2>&1; then
        ZONE_ID=$(dns_provider_aws_get_hosted_zone_id "$DOMAIN" 2>/dev/null || echo "")
        if [[ -n "$ZONE_ID" ]]; then
          # Get the zone name from AWS
          local ZONE_NAME
          ZONE_NAME=$(aws route53 get-hosted-zone --id "$ZONE_ID" --query 'HostedZone.Name' --output text 2>/dev/null | sed 's/\.$//g' || echo "$ZONE_ID")
          # Check if this zone is enabled
          if is_zone_enabled "$ZONE_NAME"; then
            HOSTED_ZONE="$ZONE_NAME ✅"
          else
            HOSTED_ZONE="$ZONE_NAME ❌"
          fi
        else
          HOSTED_ZONE="Not found"
        fi
      fi
    fi
    
    # Check if domain is enabled based on zone enablement
    local ENABLED_STATUS="No"
    if [[ "$SYNC_STATUS" == "Ready" ]]; then
      if [[ -n "$ZONE_ID" ]]; then
        # Check if the zone is enabled
        if is_domain_in_enabled_zone "$DOMAIN"; then
          ENABLED_STATUS="Yes"
        else
          ENABLED_STATUS="No (zone disabled)"
        fi
      else
        ENABLED_STATUS="No (no hosted zone)"
      fi
    else
      ENABLED_STATUS="No (provider not ready)"
    fi
    
    printf "%-30s %-8s %-15s %-15s %s\n" "$DOMAIN" "$DNS_EMOJI" "$ENABLED_STATUS" "AWS" "$HOSTED_ZONE"
  done
  
  echo
  dokku_log_info2 "Status Legend:"
  if [[ -n "$SERVER_IP" ]] && [[ "$SERVER_IP" != "Unknown" ]]; then
    dokku_log_info1 "✅ Points to server IP ($SERVER_IP)"
    dokku_log_info1 "⚠️  Points to different IP"
  else
    dokku_log_info1 "❓ Server IP unknown - cannot validate"
  fi
  dokku_log_info1 "❌ No DNS record found"
}

# Get server's public IP address
# Usage: get_server_ip
# Returns: server's public IP address, or "Unknown" if detection fails
get_server_ip() {
  local SERVER_IP=""
  local GLOBAL_DOMAINS=""
  
  if command -v dokku >/dev/null 2>&1; then
    GLOBAL_DOMAINS=$(dokku domains:report --domains-global-vhosts 2>/dev/null || echo "")
  fi
  
  if [[ -n "$GLOBAL_DOMAINS" ]] && command -v dig >/dev/null 2>&1; then
    # Use the first global domain to resolve server IP
    local FIRST_GLOBAL_DOMAIN
    FIRST_GLOBAL_DOMAIN=$(echo "$GLOBAL_DOMAINS" | head -n1)
    local RESOLVED_IP
    RESOLVED_IP=$(dig +short "$FIRST_GLOBAL_DOMAIN" 2>/dev/null | tail -n1 || echo "")
    if [[ -n "$RESOLVED_IP" ]] && [[ "$RESOLVED_IP" != "127.0.0.1" ]]; then
      SERVER_IP="$RESOLVED_IP"
    fi
  fi
  
  # If no global domains or couldn't resolve, try to get server IP another way
  if [[ -z "$SERVER_IP" ]] && command -v curl >/dev/null 2>&1; then
    # Try to get the server's public IP
    local PUBLIC_IP
    PUBLIC_IP=$(curl -s --max-time 3 ifconfig.me 2>/dev/null || curl -s --max-time 3 ipecho.net/plain 2>/dev/null || curl -s --max-time 3 icanhazip.com 2>/dev/null || echo "")
    if [[ -n "$PUBLIC_IP" ]] && [[ "$PUBLIC_IP" != "127.0.0.1" ]]; then
      SERVER_IP="$PUBLIC_IP"
    fi
  fi
  
  # If still no IP detected, return Unknown instead of broken localhost
  if [[ -z "$SERVER_IP" ]]; then
    SERVER_IP="Unknown"
  fi
  
  echo "$SERVER_IP"
}

# Check if a domain points to the server's IP
# Usage: domain_points_to_server <domain>
# Returns: 0 if domain points to server, 1 otherwise (including if server IP can't be detected)
domain_points_to_server() {
  local DOMAIN="$1"
  local SERVER_IP
  SERVER_IP=$(get_server_ip)
  
  # If we can't detect the server IP, we can't validate - fail safe
  if [[ -z "$SERVER_IP" ]] || [[ "$SERVER_IP" == "Unknown" ]]; then
    return 1
  fi
  
  if command -v dig >/dev/null 2>&1; then
    local CURRENT_IP
    CURRENT_IP=$(dig +short "$DOMAIN" A 2>/dev/null | tail -n1 || echo "")
    if [[ -n "$CURRENT_IP" ]] && [[ "$CURRENT_IP" == "$SERVER_IP" ]]; then
      return 0
    fi
  fi
  
  return 1
}

# Check if a domain matches any hosted zone that has managed domains
# Usage: dns_domain_matches_managed_zone <domain>
# Returns: 0 if domain matches a zone with managed domains, 1 otherwise
dns_domain_matches_managed_zone() {
  local DOMAIN="$1"
  
  # Check if any apps are managed by DNS
  local LINKS_FILE="$PLUGIN_DATA_ROOT/LINKS"
  if [[ ! -f "$LINKS_FILE" ]] || [[ ! -s "$LINKS_FILE" ]]; then
    # No managed apps at all
    return 1
  fi
  
  # Get all managed domains across all apps
  local all_managed_domains=()
  while IFS= read -r app; do
    [[ -z "$app" ]] && continue
    local APP_DOMAINS_FILE="$PLUGIN_DATA_ROOT/$app/DOMAINS"
    if [[ -f "$APP_DOMAINS_FILE" ]]; then
      while IFS= read -r domain; do
        [[ -n "$domain" ]] && all_managed_domains+=("$domain")
      done < "$APP_DOMAINS_FILE"
    fi
  done < "$LINKS_FILE"
  
  if [[ ${#all_managed_domains[@]} -eq 0 ]]; then
    # No managed domains at all
    return 1
  fi
  
  # Extract the zone (root domain) from the input domain
  local domain_zone
  domain_zone=$(extract_root_domain "$DOMAIN")
  
  # Check if any managed domain shares the same zone
  for managed_domain in "${all_managed_domains[@]}"; do
    local managed_zone
    managed_zone=$(extract_root_domain "$managed_domain")
    if [[ "$domain_zone" == "$managed_zone" ]]; then
      # Found a managed domain in the same zone
      return 0
    fi
  done
  
  # No managed domains in the same zone
  return 1
}

# Extract root domain from a full domain name
# Usage: extract_root_domain <domain>
# Returns: root domain (e.g., "example.com" from "api.example.com")
extract_root_domain() {
  local DOMAIN="$1"
  
  # Handle simple cases first
  local part_count
  part_count=$(echo "$DOMAIN" | tr '.' '\n' | wc -l)
  
  if [[ $part_count -le 2 ]]; then
    # Already a root domain (e.g., "example.com" or "localhost")
    echo "$DOMAIN"
    return 0
  fi
  
  # For domains with more parts, take the last two parts
  # This works for most cases: api.example.com -> example.com
  echo "$DOMAIN" | awk -F. '{print $(NF-1)"."$NF}'
}
