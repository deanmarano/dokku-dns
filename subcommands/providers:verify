#!/usr/bin/env bash
source "$(dirname "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)")/config"
set -eo pipefail
[[ $DOKKU_TRACE ]] && set -x

# Load dokku functions if available
if [[ -f "$PLUGIN_CORE_AVAILABLE_PATH/common/functions" ]]; then
  source "$PLUGIN_CORE_AVAILABLE_PATH/common/functions"
fi

# Define missing functions if needed
if ! declare -f dokku_log_info1 >/dev/null 2>&1; then
  dokku_log_info1() { echo "-----> $*"; }
fi

if ! declare -f dokku_log_info2 >/dev/null 2>&1; then
  dokku_log_info2() { echo "=====> $*"; }
fi

if ! declare -f dokku_log_warn >/dev/null 2>&1; then
  dokku_log_warn() { echo " !     $*"; }
fi

if ! declare -f dokku_log_fail >/dev/null 2>&1; then
  dokku_log_fail() { echo " !     $*" >&2; exit 1; }
fi

source "$(dirname "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)")/functions"

service-providers-verify-cmd() {
  #E verify DNS provider setup and connectivity, discover existing DNS records
  #E dokku $PLUGIN_COMMAND_PREFIX:providers:verify [provider]
  #E verify specific provider or all available providers if none specified
  #E checks credentials, tests API access, shows available zones/domains for each provider
  #A provider, optional DNS provider to verify (aws, cloudflare, digitalocean) - defaults to all available providers
  declare desc="verify DNS provider setup and connectivity"
  local cmd="$PLUGIN_COMMAND_PREFIX:providers:verify" argv=("$@")
  [[ ${argv[0]} == "$cmd" ]] && shift 1
  
  local PROVIDER_ARG="$1"
  local GLOBAL_CONFIG_ROOT="$PLUGIN_DATA_ROOT"

  # Check dependencies first
  dokku_log_info2 "Checking Dependencies"

  # Check jq following Dokku guidelines
  if ! command -v jq &>/dev/null; then
    dokku_log_fail "Missing jq, install it

jq is required for JSON processing by all DNS providers.

Install jq:
  Ubuntu/Debian:    sudo apt-get install jq
  CentOS/RHEL:      sudo yum install jq
  macOS (Homebrew): brew install jq

Or download from: https://stedolan.github.io/jq/download/"
  else
    dokku_log_info1 "  jq: available ($(jq --version))"
  fi

  echo

  # Load the provider loader system
  local LOADER_PATH
  LOADER_PATH="$(dirname "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)")/providers/loader.sh"
  if [[ ! -f "$LOADER_PATH" ]]; then
    dokku_log_fail "Provider loader system not found"
  fi
  source "$LOADER_PATH"

  # Determine which provider(s) to verify
  local PROVIDERS_TO_VERIFY=()
  if [[ -n "$PROVIDER_ARG" ]]; then
    # Specific provider requested
    if grep -q "^${PROVIDER_ARG}$" "$(dirname "$LOADER_PATH")/available"; then
      # Check if it's a test-only provider being requested in normal mode
      if [[ "$PROVIDER_ARG" =~ ^(template|mock)$ ]] && [[ -z "${DNS_TEST_MODE:-}" ]]; then
        dokku_log_fail "Provider '$PROVIDER_ARG' is only available in test mode. Available providers: $(grep -v "^#" "$(dirname "$LOADER_PATH")/available" | grep -v -E "^(template|mock)$" | tr '\n' ' ')"
      fi
      PROVIDERS_TO_VERIFY=("$PROVIDER_ARG")
    else
      dokku_log_fail "Provider '$PROVIDER_ARG' is not available. Available providers: $(grep -v "^#" "$(dirname "$LOADER_PATH")/available" | grep -v -E "^(template|mock)$" | tr '\n' ' ')"
    fi
  else
    # Verify all available providers (excluding template and mock unless in test mode)
    while IFS= read -r provider; do
      [[ "$provider" =~ ^#.*$ ]] && continue  # Skip comments
      [[ -z "$provider" ]] && continue       # Skip empty lines
      # Skip test-only providers unless in test mode
      if [[ "$provider" =~ ^(template|mock)$ ]] && [[ -z "${DNS_TEST_MODE:-}" ]]; then
        continue
      fi
      PROVIDERS_TO_VERIFY+=("$provider")
    done < "$(dirname "$LOADER_PATH")/available"
  fi

  # Create credentials directory
  local CREDENTIALS_DIR="$GLOBAL_CONFIG_ROOT/credentials"
  mkdir -p "$CREDENTIALS_DIR"
  chmod 700 "$CREDENTIALS_DIR"

  # Function to verify a specific provider
  verify_provider() {
    local provider_name="$1"

    dokku_log_info2 "Verifying $provider_name provider"
    echo

    # Try to load the provider
    if ! load_specific_provider "$provider_name" >/dev/null 2>&1; then
      dokku_log_info1 "  ✗ Provider '$provider_name' failed to load"
      return 1
    fi

    dokku_log_info1 "Current Configuration:"
    dokku_log_info1 "  DNS Provider: $provider_name"

    case "$provider_name" in
    aws)
      dokku_log_info2 "Verifying AWS Route53 Setup"
      echo
      
      # Show current configuration status
      dokku_log_info1 "Current Configuration:"
      dokku_log_info1 "  DNS Provider: AWS (only supported provider)"
      
      # Check if AWS CLI is installed
      if ! command -v aws >/dev/null 2>&1; then
        dokku_log_info1 "  ✗ AWS CLI: not installed"
        echo
        dokku_log_fail "AWS CLI is not installed. Please install it first:
  
  # Ubuntu/Debian:
  sudo apt update && sudo apt install awscli
  
  # macOS:
  brew install awscli
  
  # Or install via pip:
  pip install awscli
  
  # Or download from AWS:
  curl \"https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip\" -o \"awscliv2.zip\"
  unzip awscliv2.zip
  sudo ./aws/install"
      else
        local AWS_VERSION
        AWS_VERSION=$(aws --version 2>/dev/null | cut -d' ' -f1 || echo "unknown")
        dokku_log_info1 "  AWS CLI: installed ($AWS_VERSION)"
      fi
      
      echo
      
      # Check AWS credentials and configuration
      dokku_log_info1 "Credential Detection:"
      
      # Helper function to run AWS commands with correct user context
      run_aws_command() {
        if aws "$@" >/dev/null 2>&1; then
          aws "$@" 2>/dev/null
        elif [[ -n "${SUDO_USER:-}" ]] && sudo -u "$SUDO_USER" aws "$@" >/dev/null 2>&1; then
          sudo -u "$SUDO_USER" aws "$@" 2>/dev/null
        elif [[ -f "/home/dokku/.aws/credentials" ]] && sudo -u dokku aws "$@" >/dev/null 2>&1; then
          sudo -u dokku aws "$@" 2>/dev/null
        else
          return 1
        fi
      }
      
      # Check different credential sources
      local CREDENTIALS_DETECTED=false
      local CREDENTIAL_SOURCE=""
      
      # Check environment variables
      if [[ -n "${AWS_ACCESS_KEY_ID:-}" ]] && [[ -n "${AWS_SECRET_ACCESS_KEY:-}" ]]; then
        dokku_log_info1 "  Environment variables: AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY"
        CREDENTIALS_DETECTED=true
        CREDENTIAL_SOURCE="environment"
      else
        dokku_log_info1 "  ✗ Environment variables: not set"
      fi
      
      # Check AWS CLI configuration files
      local AWS_CONFIG_STATUS="✗"
      if [[ -f ~/.aws/credentials ]] || [[ -f ~/.aws/config ]]; then
        AWS_CONFIG_STATUS="YES"
        CREDENTIALS_DETECTED=true
        if [[ -z "$CREDENTIAL_SOURCE" ]]; then
          CREDENTIAL_SOURCE="aws-config"
        fi
      fi
      dokku_log_info1 "  $AWS_CONFIG_STATUS AWS config files: ~/.aws/credentials, ~/.aws/config"
      
      # Check IAM role (EC2 metadata)
      if curl -s --max-time 2 http://169.254.169.254/latest/meta-data/iam/security-credentials/ >/dev/null 2>&1; then
        dokku_log_info1 "  IAM Role: available (EC2 instance)"
        CREDENTIALS_DETECTED=true
        if [[ -z "$CREDENTIAL_SOURCE" ]]; then
          CREDENTIAL_SOURCE="iam-role"
        fi
      else
        dokku_log_info1 "  ✗ IAM Role: not available"
      fi
      
      echo
      
      # Try to authenticate and get AWS identity
      dokku_log_info1 "Testing AWS Authentication:"
      local AWS_CHECK_SUCCESS=false
      
      if run_aws_command sts get-caller-identity >/dev/null 2>&1; then
        AWS_CHECK_SUCCESS=true
        # Determine which context is working for user feedback
        if aws sts get-caller-identity >/dev/null 2>&1; then
          dokku_log_info1 "  Authentication successful (current context)"
        elif [[ -n "${SUDO_USER:-}" ]]; then
          dokku_log_info1 "  Authentication successful (user: $SUDO_USER)"
        else
          dokku_log_info1 "  Authentication successful (dokku user)"
        fi
      else
        dokku_log_info1 "  ✗ Authentication failed"
      fi
      
      if [[ "$AWS_CHECK_SUCCESS" != "true" ]]; then
        echo
        dokku_log_fail "AWS CLI is not configured or credentials are invalid.

Please configure AWS credentials using one of these methods:

Method 1 - Using dokku config:set (Recommended for Dokku):
  dokku config:set --global AWS_ACCESS_KEY_ID=your_access_key_id
  dokku config:set --global AWS_SECRET_ACCESS_KEY=your_secret_access_key  
  dokku config:set --global AWS_DEFAULT_REGION=us-east-1

Method 2 - Using aws configure:
  aws configure
  # Then enter your AWS Access Key ID, Secret Key, and default region

Method 3 - Using environment variables:
  export AWS_ACCESS_KEY_ID=your_key_id
  export AWS_SECRET_ACCESS_KEY=your_secret_key
  export AWS_DEFAULT_REGION=us-east-1

Method 4 - Using IAM roles (if running on EC2):
  # Attach an IAM role with Route53 permissions to your EC2 instance

Method 5 - Using AWS credential files:
  # Edit ~/.aws/credentials and ~/.aws/config

Required AWS Permissions:
  - route53:ListHostedZones
  - route53:ListResourceRecordSets
  - route53:ChangeResourceRecordSets

For more info: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-quickstart.html"
      fi
      
      echo
      
      # Get detailed AWS identity information
      dokku_log_info1 "AWS Account Details:"
      local AWS_IDENTITY AWS_USER_ID AWS_ACCOUNT AWS_REGION AWS_ARN
      
      AWS_IDENTITY=$(run_aws_command sts get-caller-identity)
      AWS_REGION=$(run_aws_command configure get region 2>/dev/null || echo "not-set")
      
      if [[ -n "$AWS_IDENTITY" ]]; then
        AWS_USER_ID=$(echo "$AWS_IDENTITY" | jq -r '.UserId' 2>/dev/null || echo "unknown")
        AWS_ACCOUNT=$(echo "$AWS_IDENTITY" | jq -r '.Account' 2>/dev/null || echo "unknown")
        AWS_ARN=$(echo "$AWS_IDENTITY" | jq -r '.Arn' 2>/dev/null || echo "unknown")
        
        dokku_log_info1 "  Account ID: $AWS_ACCOUNT"
        dokku_log_info1 "  User/Role ARN: $AWS_ARN"
        dokku_log_info1 "  User ID: $AWS_USER_ID"
        dokku_log_info1 "  Region: $AWS_REGION"
        
        if [[ "$AWS_REGION" == "not-set" ]]; then
          dokku_log_warn "  No default region set. Consider setting AWS_DEFAULT_REGION"
        fi
      else
        dokku_log_info1 "  ✗ Could not retrieve AWS identity"
      fi
      
      echo
      
      # Test Route53 permissions comprehensively
      dokku_log_info1 "Testing Route53 API Access:"
      local ROUTE53_SUCCESS=false
      
      # Test list-hosted-zones permission
      if run_aws_command route53 list-hosted-zones >/dev/null 2>&1; then
        dokku_log_info1 "  route53:ListHostedZones - can list hosted zones"
        ROUTE53_SUCCESS=true
        
        # Get zone count
        local ZONE_COUNT
        ZONE_COUNT=$(run_aws_command route53 list-hosted-zones --query 'length(HostedZones)' --output text 2>/dev/null || echo "0")
        dokku_log_info1 "  Found $ZONE_COUNT hosted zone(s)"
        
        # Test record listing if zones exist
        if [[ "$ZONE_COUNT" -gt 0 ]]; then
          local FIRST_ZONE_ID
          FIRST_ZONE_ID=$(run_aws_command route53 list-hosted-zones --query 'HostedZones[0].Id' --output text 2>/dev/null | sed 's|/hostedzone/||')
          
          if [[ -n "$FIRST_ZONE_ID" ]] && run_aws_command route53 list-resource-record-sets --hosted-zone-id "$FIRST_ZONE_ID" >/dev/null 2>&1; then
            dokku_log_info1 "  route53:ListResourceRecordSets - can read DNS records"
          else
            dokku_log_info1 "  route53:ListResourceRecordSets - permission test failed"
          fi
          
          # Note: We can't easily test ChangeResourceRecordSets without making actual changes
          dokku_log_info1 "  ? route53:ChangeResourceRecordSets - will be tested during actual sync operations"
        fi
      else
        dokku_log_info1 "  ✗ route53:ListHostedZones - permission denied or API error"
      fi
      
      if [[ "$ROUTE53_SUCCESS" == "true" ]]; then
        echo
        dokku_log_info1 "Hosted Zones Discovery:"
        
        # Show available hosted zones in a nice format
        local ZONES_OUTPUT
        ZONES_OUTPUT=$(run_aws_command route53 list-hosted-zones --query 'HostedZones[].{Zone:Name,ID:Id,Records:ResourceRecordSetCount,Type:Config.PrivateZone}' --output table 2>/dev/null)
        
        if [[ -n "$ZONES_OUTPUT" ]]; then
          echo "$ZONES_OUTPUT"
        else
          # Fallback to simple text output
          dokku_log_info1 "Available zones:"
          run_aws_command route53 list-hosted-zones --query 'HostedZones[].Name' --output text 2>/dev/null | tr '\t' '\n' | sed 's/^/  /' || dokku_log_info1 "  No hosted zones found"
        fi
        
        echo
        # Show existing DNS records for Dokku domains
        dokku_log_info1 "Dokku DNS Records Discovery:"
        if init_provider_system >/dev/null 2>&1; then
          # Use the adapter system to discover existing domains
          dokku_log_info1 "  DNS discovery available through adapter system"
        else
          dokku_log_info1 "  No existing Dokku DNS records found"
        fi
      else
        echo
        dokku_log_fail "Route53 access failed. Please ensure your AWS credentials have the following permissions:

Required AWS Route53 Permissions:
  - route53:ListHostedZones        (list available DNS zones)
  - route53:ListResourceRecordSets (read existing DNS records)  
  - route53:ChangeResourceRecordSets (create/update/delete DNS records)

You can either:
1. Attach the AWS managed policy 'AmazonRoute53FullAccess'
2. Create a custom policy with the permissions above

Policy JSON example:
{
    \"Version\": \"2012-10-17\",
    \"Statement\": [
        {
            \"Effect\": \"Allow\",
            \"Action\": [
                \"route53:ListHostedZones\",
                \"route53:ListResourceRecordSets\",
                \"route53:ChangeResourceRecordSets\"
            ],
            \"Resource\": \"*\"
        }
    ]
}"
      fi
      ;;

    cloudflare)
      dokku_log_info1 "Cloudflare API Token Detection:"

      # Check for Cloudflare API token
      if [[ -z "${CLOUDFLARE_API_TOKEN:-}" ]]; then
        dokku_log_info1 "  ✗ CLOUDFLARE_API_TOKEN: not set"
        echo
        dokku_log_fail "Cloudflare API token not found.

Configure your Cloudflare API token:

Method 1 - Using dokku config:set (Recommended):
  dokku config:set --global CLOUDFLARE_API_TOKEN=your_api_token

Method 2 - Using environment variables:
  export CLOUDFLARE_API_TOKEN=your_api_token

Get your API token from: https://dash.cloudflare.com/profile/api-tokens

Required permissions:
  - Zone:Zone:Read
  - Zone:DNS:Edit"
      else
        dokku_log_info1 "  ✓ CLOUDFLARE_API_TOKEN: configured"
      fi

      echo

      # Test Cloudflare API connectivity
      dokku_log_info1 "Testing Cloudflare API Access:"

      # Call provider validation function
      if provider_validate_credentials >/dev/null 2>&1; then
        dokku_log_info1 "  ✓ API Authentication: successful"

        # Test zone listing
        if provider_list_zones >/dev/null 2>&1; then
          local zone_count
          zone_count=$(provider_list_zones 2>/dev/null | wc -l)
          dokku_log_info1 "  ✓ Zone Access: can list zones ($zone_count zone(s) available)"

          # Show available zones
          if [[ $zone_count -gt 0 ]]; then
            echo
            dokku_log_info1 "Available Cloudflare Zones:"
            provider_list_zones 2>/dev/null | sed 's/^/  /'
          fi
        else
          dokku_log_info1 "  ⚠ Zone Access: limited (check token permissions)"
        fi
      else
        dokku_log_info1 "  ✗ API Authentication: failed"
        echo
        dokku_log_fail "Cloudflare API authentication failed. Please check your API token.

Troubleshooting:
1. Verify your API token is correct
2. Check token permissions include Zone:Zone:Read and Zone:DNS:Edit
3. Ensure the token hasn't expired

Get a new token from: https://dash.cloudflare.com/profile/api-tokens"
      fi
      ;;

    digitalocean)
      dokku_log_info1 "DigitalOcean API Token Detection:"

      # Check for DigitalOcean API token
      if [[ -z "${DIGITALOCEAN_ACCESS_TOKEN:-}" ]]; then
        dokku_log_info1 "  ✗ DIGITALOCEAN_ACCESS_TOKEN: not set"
        echo
        dokku_log_fail "DigitalOcean API token not found.

Configure your DigitalOcean API token:

Method 1 - Using dokku config:set (Recommended):
  dokku config:set --global DIGITALOCEAN_ACCESS_TOKEN=your_api_token

Method 2 - Using environment variables:
  export DIGITALOCEAN_ACCESS_TOKEN=your_api_token

Get your API token from: https://cloud.digitalocean.com/account/api/tokens

Required scopes: Read and Write"
      else
        dokku_log_info1 "  ✓ DIGITALOCEAN_ACCESS_TOKEN: configured"
      fi

      echo

      # Test DigitalOcean API connectivity
      dokku_log_info1 "Testing DigitalOcean API Access:"

      # Call provider validation function
      if provider_validate_credentials >/dev/null 2>&1; then
        dokku_log_info1 "  ✓ API Authentication: successful"

        # Test domain listing
        if provider_list_zones >/dev/null 2>&1; then
          local domain_count
          domain_count=$(provider_list_zones 2>/dev/null | wc -l)
          dokku_log_info1 "  ✓ Domain Access: can list domains ($domain_count domain(s) available)"

          # Show available domains
          if [[ $domain_count -gt 0 ]]; then
            echo
            dokku_log_info1 "Available DigitalOcean Domains:"
            provider_list_zones 2>/dev/null | sed 's/^/  /'
          fi
        else
          dokku_log_info1 "  ⚠ Domain Access: limited (check token permissions)"
        fi
      else
        dokku_log_info1 "  ✗ API Authentication: failed"
        echo
        dokku_log_fail "DigitalOcean API authentication failed. Please check your API token.

Troubleshooting:
1. Verify your API token is correct
2. Check token has Read and Write scopes
3. Ensure the token hasn't been revoked

Get a new token from: https://cloud.digitalocean.com/account/api/tokens"
      fi
      ;;

    *)
      dokku_log_fail "Unknown provider: $provider_name"
      ;;
    esac

    echo
    dokku_log_info1 "$provider_name provider verification complete"
  }

  # Verify each provider
  for provider in "${PROVIDERS_TO_VERIFY[@]}"; do
    verify_provider "$provider"
    echo
  done

  echo
  dokku_log_info1 "DNS Provider Verification Complete"

  exit 0
}

service-providers-verify-cmd "$@"