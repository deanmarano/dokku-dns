#!/usr/bin/env bash
source "$(dirname "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)")/config"
set -eo pipefail
[[ $DOKKU_TRACE ]] && set -x

# Load dokku functions if available
if [[ -f "$PLUGIN_CORE_AVAILABLE_PATH/common/functions" ]]; then
  source "$PLUGIN_CORE_AVAILABLE_PATH/common/functions"
fi

source "$(dirname "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)")/functions"

# Load provider adapter system
ADAPTER_PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/../providers/adapter.sh"
if [[ -f "$ADAPTER_PATH" ]]; then
  source "$ADAPTER_PATH"
fi

# Load multi-provider for DNS operations
PLUGIN_BASE_PATH="$(dirname "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)")"
if [[ -f "$PLUGIN_BASE_PATH/providers/multi-provider.sh" ]]; then
  source "$PLUGIN_BASE_PATH/providers/multi-provider.sh"
fi

#E Remove DNS records from the pending deletions queue
#E dokku $PLUGIN_COMMAND_PREFIX:sync:deletions [--force]
#E
#E Processes the pending deletions queue and removes DNS records that were
#E queued for deletion when apps were destroyed or domains were removed.
#E
#E This command only deletes records that were explicitly tracked and queued
#E by the plugin. It will never scan Route53 for orphaned records.
#E
#E Options:
#E   --force   Skip confirmation prompt and delete immediately
#E
#E Examples:
#E   dokku $PLUGIN_COMMAND_PREFIX:sync:deletions
#E   dokku $PLUGIN_COMMAND_PREFIX:sync:deletions --force
#A --force, skip confirmation prompt

service-sync-deletions-cmd() {
  declare desc="remove DNS records from the pending deletions queue"
  local cmd="$PLUGIN_COMMAND_PREFIX:sync:deletions"
  [[ "$1" == "$cmd" ]] && shift 1

  # Parse arguments
  local FORCE=false
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --force)
        FORCE=true
        shift
        ;;
      *)
        dokku_log_fail "Unknown option: $1"
        ;;
    esac
  done

  dokku_log_info1 "DNS Record Deletion Queue"
  echo

  # Check if pending deletions file exists
  local PENDING_DELETIONS_FILE="$PLUGIN_DATA_ROOT/PENDING_DELETIONS"
  if [[ ! -f "$PENDING_DELETIONS_FILE" ]] || [[ ! -s "$PENDING_DELETIONS_FILE" ]]; then
    dokku_log_info1 "No pending deletions"
    dokku_log_info2 "The deletion queue is empty"
    return 0
  fi

  # Read pending deletions
  local -a pending_deletions=()
  while IFS=: read -r domain zone_id timestamp; do
    [[ -z "$domain" ]] && continue
    pending_deletions+=("$domain:$zone_id:$timestamp")
  done < "$PENDING_DELETIONS_FILE"

  if [[ ${#pending_deletions[@]} -eq 0 ]]; then
    dokku_log_info1 "No pending deletions"
    dokku_log_info2 "The deletion queue is empty"
    return 0
  fi

  # Display queued deletions in Terraform-style format
  dokku_log_info1 "Queued Deletions:"
  echo

  for entry in "${pending_deletions[@]}"; do
    IFS=: read -r domain zone_id timestamp <<< "$entry"
    local date_str=""
    if [[ -n "$timestamp" ]] && command -v date >/dev/null 2>&1; then
      date_str=$(date -d "@$timestamp" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "")
    fi
    if [[ -n "$date_str" ]]; then
      echo "  - $domain (A record) [queued: $date_str]"
    else
      echo "  - $domain (A record)"
    fi
  done

  echo
  dokku_log_info2 "Plan: 0 to add, 0 to change, ${#pending_deletions[@]} to destroy"
  echo

  # Confirmation prompt unless --force is specified
  if [[ "$FORCE" != "true" ]]; then
    echo
    read -rp "Do you want to delete these ${#pending_deletions[@]} DNS records? [y/N] " confirm
    echo

    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
      dokku_log_info1 "Deletion cancelled"
      return 0
    fi
  fi

  # Process deletions
  dokku_log_info1 "Deleting DNS records..."
  echo

  local deleted_count=0
  local failed_count=0
  local -a successfully_deleted=()

  for entry in "${pending_deletions[@]}"; do
    IFS=: read -r domain zone_id timestamp <<< "$entry"

    printf "  %s... " "$domain"

    # Validate zone_id
    if [[ -z "$zone_id" ]]; then
      echo "❌ Failed (no zone ID)"
      failed_count=$((failed_count + 1))
      continue
    fi

    # Get current record value
    local record_value=""
    if declare -f multi_get_record >/dev/null 2>&1; then
      record_value=$(multi_get_record "$zone_id" "$domain" "A" 2>/dev/null || echo "")
    fi

    if [[ -z "$record_value" ]]; then
      echo "⚠️  Already deleted or not found"
      successfully_deleted+=("$domain")
      deleted_count=$((deleted_count + 1))
      continue
    fi

    # Delete the record
    local deletion_successful=false
    if declare -f multi_delete_record >/dev/null 2>&1; then
      if multi_delete_record "$zone_id" "$domain" "A" "$record_value" 2>/dev/null; then
        deletion_successful=true
      fi
    fi

    if [[ "$deletion_successful" == "true" ]]; then
      echo "✅ Deleted"
      successfully_deleted+=("$domain")
      deleted_count=$((deleted_count + 1))
    else
      echo "❌ Failed"
      failed_count=$((failed_count + 1))
    fi
  done

  # Remove successfully deleted domains from the queue
  if [[ ${#successfully_deleted[@]} -gt 0 ]]; then
    local temp_file
    temp_file=$(mktemp)

    # Write all entries except successfully deleted ones
    for entry in "${pending_deletions[@]}"; do
      IFS=: read -r domain zone_id timestamp <<< "$entry"
      local is_deleted=false

      for deleted_domain in "${successfully_deleted[@]}"; do
        if [[ "$domain" == "$deleted_domain" ]]; then
          is_deleted=true
          break
        fi
      done

      if [[ "$is_deleted" == "false" ]]; then
        echo "$entry" >> "$temp_file"
      fi
    done

    mv "$temp_file" "$PENDING_DELETIONS_FILE"
  fi

  # Display summary
  echo
  if [[ $deleted_count -gt 0 ]]; then
    dokku_log_info1 "Successfully deleted $deleted_count of ${#pending_deletions[@]} DNS records"
  fi

  if [[ $failed_count -gt 0 ]]; then
    dokku_log_warn "$failed_count deletion(s) failed"
    return 1
  fi

  return 0
}

service-sync-deletions-cmd "$@"
