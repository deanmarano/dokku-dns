#!/usr/bin/env bash
source "$(dirname "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)")/config"
set -eo pipefail
[[ $DOKKU_TRACE ]] && set -x

# Load dokku functions if available
if [[ -f "$PLUGIN_CORE_AVAILABLE_PATH/common/functions" ]]; then
  source "$PLUGIN_CORE_AVAILABLE_PATH/common/functions"
fi

# Define missing functions if needed
if ! declare -f verify_app_name >/dev/null 2>&1; then
  verify_app_name() {
    local app="$1"
    [[ -n "$app" ]] || { echo " !     Please specify an app name" >&2; exit 1; }
  }
fi

if ! declare -f dokku_log_info1 >/dev/null 2>&1; then
  dokku_log_info1() { echo "-----> $*"; }
fi

if ! declare -f dokku_log_info2 >/dev/null 2>&1; then
  dokku_log_info2() { echo "=====> $*"; }
fi

if ! declare -f dokku_log_warn >/dev/null 2>&1; then
  dokku_log_warn() { echo " !     $*"; }
fi

source "$(dirname "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)")/functions"

service-report-cmd() {
  #E display DNS status and domain information for app(s)
  #E dokku $PLUGIN_COMMAND_PREFIX:report [app]
  #E shows server IP, domains, DNS status with emojis, and hosted zones
  #E without app: shows all apps and their domains
  #E with app: shows detailed report for specific app
  #E DNS status: CORRECT correct, WARNING wrong IP, ERROR no record
  #A app, app to generate DNS report for (optional - shows all apps if omitted)
  declare desc="display DNS status and domain information for app(s)"
  local cmd="$PLUGIN_COMMAND_PREFIX:report" argv=("$@")
  [[ ${argv[0]} == "$cmd" ]] && shift 1
  declare APP="$1"

  if [[ -z "$APP" ]]; then
    dns_global_report
  else
    verify_app_name "$APP"
    dns_report "$APP"
  fi
}

dns_global_report() {
  local GLOBAL_CONFIG_ROOT="$PLUGIN_DATA_ROOT"
  local PROVIDER_FILE="$GLOBAL_CONFIG_ROOT/PROVIDER"
  
  dokku_log_info2 "DNS Global Report - All Apps"
  dokku_log_info2 "$(printf "%-50s" "==================================")"
  
  # Get server's public IP first (handle failure gracefully)
  local SERVER_IP
  SERVER_IP=$(get_server_ip)
  
  dokku_log_info1 "Server Public IP: $SERVER_IP"
  
  if [[ "$SERVER_IP" == "Unknown" ]]; then
    dokku_log_warn "Cannot detect server IP for DNS validation"
    dokku_log_info1 "Consider configuring global domains: dokku domains:add-global <domain>"
  fi
  
  # Check global DNS configuration
  local PROVIDER="None"
  local CONFIG_STATUS="Not configured"
  
  if [[ -f "$PROVIDER_FILE" ]]; then
    PROVIDER=$(cat "$PROVIDER_FILE" 2>/dev/null || echo "None")
    if [[ -n "$PROVIDER" ]] && [[ "$PROVIDER" != "None" ]]; then
      CONFIG_STATUS="Configured"
    fi
  fi
  
  # Detect current provider dynamically
  local CURRENT_PROVIDER="None"
  local PROVIDERS_DIR
  PROVIDERS_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/../providers"
  if [[ -f "$PROVIDERS_DIR/loader.sh" ]]; then
    source "$PROVIDERS_DIR/loader.sh"
    if auto_load_provider >/dev/null 2>&1; then
      CURRENT_PROVIDER=$(get_current_provider 2>/dev/null || echo "None")
    fi
  fi
  
  # Display global configuration  
  dokku_log_info1 "DNS Provider: $(echo "$CURRENT_PROVIDER" | tr '[:lower:]' '[:upper:]')"
  dokku_log_info1 "Configuration Status: $CONFIG_STATUS"
  
  # Get apps under DNS management
  local APPS_LIST
  APPS_LIST=$(get_dns_managed_apps)
  
  if [[ -z "$APPS_LIST" ]]; then
    dokku_log_warn "No apps have been added to DNS"
    dokku_log_info1 "Add an app to DNS with: dokku $PLUGIN_COMMAND_PREFIX:apps:enable <app-name>"
    return 0
  fi
  
  # Check global provider credentials
  local CREDENTIALS_DIR="$GLOBAL_CONFIG_ROOT/credentials"
  local SYNC_STATUS="Not ready"
  
  if [[ "$PROVIDER" != "None" ]]; then
    case "$PROVIDER" in
      aws)
        if [[ -d "$CREDENTIALS_DIR" ]] && [[ -f "$CREDENTIALS_DIR/AWS_ACCESS_KEY_ID" ]]; then
          SYNC_STATUS="Ready"
        elif aws sts get-caller-identity >/dev/null 2>&1; then
          SYNC_STATUS="Ready"
        else
          SYNC_STATUS="Missing auth"
        fi
        ;;
      cloudflare)
        if [[ -d "$CREDENTIALS_DIR" ]] && [[ -f "$CREDENTIALS_DIR/CLOUDFLARE_API_TOKEN" ]]; then
          SYNC_STATUS="Ready"
        else
          SYNC_STATUS="Missing auth"
        fi
        ;;
      *)
        SYNC_STATUS="Unknown provider"
        ;;
    esac
  else
    SYNC_STATUS="Not configured"
  fi
  
  # Load provider functions if available
  if [[ "$PROVIDER" != "None" ]] && [[ "$SYNC_STATUS" == "Ready" ]]; then
    local PROVIDER_SCRIPT
    PROVIDER_SCRIPT="$(dirname "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)")/providers/$PROVIDER"
    if [[ -f "$PROVIDER_SCRIPT" ]]; then
      source "$PROVIDER_SCRIPT"
      if [[ "$PROVIDER" == "aws" ]]; then
        dns_provider_aws_setup_env
      fi
    fi
  fi
  
  echo
  dokku_log_info2 "All Apps Domain Analysis:"
  printf "%-15s %-30s %-8s %-15s %-12s %s\n" "App" "Domain" "DNS" "Status" "Provider" "Zone (Enabled)"
  printf "%-15s %-30s %-8s %-15s %-12s %s\n" "---" "------" "---" "------" "--------" "---------------"
  
  # First pass: collect all domains from DNS DOMAINS files and count them
  local ALL_DOMAINS=""
  local TOTAL_DOMAINS=0
  local SYNCED_DOMAINS=0
  
  while IFS= read -r APP; do
    [[ -z "$APP" ]] && continue
    
    # Get domains that were actually added to DNS (from per-app DOMAINS file)
    local APP_DOMAINS_FILE="$PLUGIN_DATA_ROOT/$APP/DOMAINS"
    if [[ -f "$APP_DOMAINS_FILE" ]]; then
      while IFS= read -r DOMAIN; do
        [[ -z "$DOMAIN" ]] && continue
        ALL_DOMAINS="${ALL_DOMAINS}${APP}:${DOMAIN}\n"
        TOTAL_DOMAINS=$((TOTAL_DOMAINS + 1))
      done < "$APP_DOMAINS_FILE"
    fi
  done <<< "$APPS_LIST"
  
  # Convert to proper format for processing
  if [[ -n "$ALL_DOMAINS" ]]; then
    ALL_DOMAINS=$(echo -e "$ALL_DOMAINS" | grep -v "^$")
  fi
  
  # Analyze each app and display only domains that were actually added to DNS
  while IFS= read -r APP; do
    [[ -z "$APP" ]] && continue
    
    # Get domains that were actually added to DNS (from per-app DOMAINS file)
    local APP_DNS_DOMAINS=""
    local APP_DOMAINS_FILE="$PLUGIN_DATA_ROOT/$APP/DOMAINS"
    if [[ -f "$APP_DOMAINS_FILE" ]]; then
      APP_DNS_DOMAINS=$(tr '\n' ' ' < "$APP_DOMAINS_FILE" 2>/dev/null)
    fi
    
    if [[ -z "$APP_DNS_DOMAINS" ]]; then
      printf "%-15s %-30s %-8s %-15s %-12s %s\n" "$APP" "(no domains added)" "NONE" "Not added" "$PROVIDER" "-"
    else
      local FIRST_DOMAIN=true
      for DOMAIN in $APP_DNS_DOMAINS; do
        [[ -z "$DOMAIN" ]] && continue
        
        # Get current DNS resolution (handle failure gracefully, use provider-specific checking)
        local CURRENT_IP=""
        CURRENT_IP=$(dns_get_record_ip "$DOMAIN" "$PROVIDER" || echo "")
        
        # Determine DNS status
        local DNS_STATUS="ERROR"
        if [[ -n "$CURRENT_IP" ]]; then
          if [[ -n "$SERVER_IP" ]] && [[ "$SERVER_IP" != "Unknown" ]] && [[ "$CURRENT_IP" == "$SERVER_IP" ]]; then
            DNS_STATUS="OK"
          elif [[ -n "$SERVER_IP" ]] && [[ "$SERVER_IP" != "Unknown" ]]; then
            DNS_STATUS="WARNING"
          else
            # Server IP unknown, can't validate
            DNS_STATUS="UNKNOWN"
          fi
        fi
        
        # These domains are from the DOMAINS file, so they were added
        local APP_DNS_STATUS="Added"
        
        # Try to get hosted zone if provider is AWS and ready (handle failure gracefully)
        local HOSTED_ZONE="-"
        if [[ "$PROVIDER" == "aws" ]] && [[ "$SYNC_STATUS" == "Ready" ]]; then
          if declare -f "dns_provider_aws_get_hosted_zone_id" >/dev/null 2>&1; then
            local ZONE_ID=""
            ZONE_ID=$(dns_provider_aws_get_hosted_zone_id "$DOMAIN" 2>/dev/null || echo "")
            if [[ -n "$ZONE_ID" ]]; then
              # Get the zone name from AWS (handle failure gracefully)
              local ZONE_NAME=""
              if command -v aws >/dev/null 2>&1; then
                ZONE_NAME=$(aws route53 get-hosted-zone --id "$ZONE_ID" --query 'HostedZone.Name' --output text 2>/dev/null | sed 's/\.$//g' || echo "$ZONE_ID")
              else
                ZONE_NAME="$ZONE_ID"
              fi
              # Check if this zone is enabled
              if is_zone_enabled "$ZONE_NAME"; then
                HOSTED_ZONE="$ZONE_NAME (enabled)"
              else
                HOSTED_ZONE="$ZONE_NAME (disabled)"
              fi
            else
              HOSTED_ZONE="Not found"
            fi
          fi
        elif [[ "$PROVIDER" == "aws" ]]; then
          # Provider is AWS but not ready, still check if domain is in enabled zone
          if is_domain_in_enabled_zone "$DOMAIN"; then
            HOSTED_ZONE="Zone enabled"
          else
            HOSTED_ZONE="Zone disabled"
          fi
        fi
        
        # Show app name only for first domain
        local APP_DISPLAY="$APP"
        if [[ "$FIRST_DOMAIN" != true ]]; then
          APP_DISPLAY=""
        fi
        FIRST_DOMAIN=false
        
        # Format and display the row
        printf "%-15s %-30s %-8s %-15s %-12s %s\n" "$APP_DISPLAY" "$DOMAIN" "$DNS_STATUS" "$APP_DNS_STATUS" "$PROVIDER" "$HOSTED_ZONE"
      done
    fi
  done <<< "$APPS_LIST"
  
  # Count correctly configured domains separately to avoid subshell issues
  CORRECTLY_CONFIGURED_DOMAINS=0
  if [[ -n "$ALL_DOMAINS" ]] && [[ "$TOTAL_DOMAINS" -gt 0 ]]; then
    while IFS=: read -r APP DOMAIN; do
      [[ -z "$APP" ]] && continue
      [[ -z "$DOMAIN" ]] && continue
      local CURRENT_IP
      CURRENT_IP=$(dns_get_record_ip "$DOMAIN" "$PROVIDER" || echo "")
      if [[ -n "$CURRENT_IP" ]] && [[ "$CURRENT_IP" == "$SERVER_IP" ]]; then
        ((CORRECTLY_CONFIGURED_DOMAINS++))
      fi
    done <<< "$ALL_DOMAINS"
  fi
  
  echo
  dokku_log_info2 "Summary:"
  dokku_log_info1 "Total domains: $TOTAL_DOMAINS"
  dokku_log_info1 "Correctly configured: $CORRECTLY_CONFIGURED_DOMAINS"
  if [[ "$TOTAL_DOMAINS" -gt 0 ]]; then
    local CONFIG_PERCENTAGE=$((CORRECTLY_CONFIGURED_DOMAINS * 100 / TOTAL_DOMAINS))
    dokku_log_info1 "DNS status: ${CONFIG_PERCENTAGE}% correctly configured"
  fi
  
  # Show pending changes if provider is ready
  if [[ "$PROVIDER" != "None" ]] && [[ "$SYNC_STATUS" == "Ready" ]]; then
    dns_display_global_pending_changes
  fi

}

dns_report() {
  local APP="$1"
  local GLOBAL_CONFIG_ROOT="$PLUGIN_DATA_ROOT"
  local PROVIDER_FILE="$GLOBAL_CONFIG_ROOT/PROVIDER"
  
  # Check if app has been added to DNS
  local APP_IS_ADDED=false
  if is_app_dns_managed "$APP"; then
    APP_IS_ADDED=true
  fi
  
  dokku_log_info2 "DNS Report for app: $APP"
  dokku_log_info2 "$(printf "%-50s" "==============================")"
  
  # Get server's public IP first
  local SERVER_IP
  SERVER_IP=$(get_server_ip)
  
  dokku_log_info1 "Server Public IP: $SERVER_IP"
  
  if [[ "$SERVER_IP" == "Unknown" ]]; then
    dokku_log_warn "Cannot detect server IP for DNS validation"
    dokku_log_info1 "Consider configuring global domains: dokku domains:add-global <domain>"
  fi
  
  # Get app domains
  local APP_DOMAINS
  APP_DOMAINS=$(dokku domains:report "$APP" --domains-app-vhosts 2>/dev/null || echo "")
  
  if [[ -z "$APP_DOMAINS" ]]; then
    dokku_log_warn "No domains configured for app: $APP"
    dokku_log_info1 "Add domains with: dokku domains:add $APP <domain>"
    return 0
  fi
  
  # Check global DNS configuration
  local PROVIDER="None"
  local CONFIG_STATUS="Not configured"
  
  if [[ -f "$PROVIDER_FILE" ]]; then
    PROVIDER=$(cat "$PROVIDER_FILE" 2>/dev/null || echo "None")
    if [[ -n "$PROVIDER" ]] && [[ "$PROVIDER" != "None" ]]; then
      CONFIG_STATUS="Configured"
    fi
  fi
  
  # Detect current provider dynamically for single app report
  local CURRENT_PROVIDER="None"
  local PROVIDERS_DIR
  PROVIDERS_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/../providers"
  if [[ -f "$PROVIDERS_DIR/loader.sh" ]]; then
    source "$PROVIDERS_DIR/loader.sh"
    if auto_load_provider >/dev/null 2>&1; then
      CURRENT_PROVIDER=$(get_current_provider 2>/dev/null || echo "None")
    fi
  fi
  
  # Display global configuration
  dokku_log_info1 "DNS Provider: $(echo "$CURRENT_PROVIDER" | tr '[:lower:]' '[:upper:]')"
  dokku_log_info1 "Configuration Status: $CONFIG_STATUS"
  
  # Display DNS add status
  if [[ "$APP_IS_ADDED" == "true" ]]; then
    dokku_log_info1 "DNS Status: Added"
  else
    dokku_log_info1 "DNS Status: Not added (add with: dokku $PLUGIN_COMMAND_PREFIX:apps:enable $APP)"
  fi
  
  echo
  dokku_log_info2 "Domain Analysis:"
  printf "%-30s %-8s %-15s %-15s %s\n" "Domain" "Status" "Enabled" "Provider" "Zone (Enabled)"
  printf "%-30s %-8s %-15s %-15s %s\n" "------" "------" "-------" "--------" "---------------"
  
  # Check global provider credentials
  local CREDENTIALS_DIR="$GLOBAL_CONFIG_ROOT/credentials"
  local SYNC_STATUS="Not ready"
  
  if [[ "$PROVIDER" != "None" ]]; then
    case "$PROVIDER" in
      aws)
        if [[ -d "$CREDENTIALS_DIR" ]] && [[ -f "$CREDENTIALS_DIR/AWS_ACCESS_KEY_ID" ]]; then
          SYNC_STATUS="Ready"
        elif aws sts get-caller-identity >/dev/null 2>&1; then
          SYNC_STATUS="Ready"
        else
          SYNC_STATUS="Missing auth"
        fi
        ;;
      cloudflare)
        if [[ -d "$CREDENTIALS_DIR" ]] && [[ -f "$CREDENTIALS_DIR/CLOUDFLARE_API_TOKEN" ]]; then
          SYNC_STATUS="Ready"
        else
          SYNC_STATUS="Missing auth"
        fi
        ;;
      *)
        SYNC_STATUS="Unknown provider"
        ;;
    esac
  else
    SYNC_STATUS="Not configured"
  fi
  
  # Load provider functions if available
  if [[ "$PROVIDER" != "None" ]] && [[ "$SYNC_STATUS" == "Ready" ]]; then
    local PROVIDER_SCRIPT
    PROVIDER_SCRIPT="$(dirname "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)")/providers/$PROVIDER"
    if [[ -f "$PROVIDER_SCRIPT" ]]; then
      source "$PROVIDER_SCRIPT"
      if [[ "$PROVIDER" == "aws" ]]; then
        dns_provider_aws_setup_env
      fi
    fi
  fi
  
  # Analyze each domain - split space-separated domains properly
  for DOMAIN in $APP_DOMAINS; do
    [[ -z "$DOMAIN" ]] && continue
    
    # Get current DNS resolution
    local CURRENT_IP
    CURRENT_IP=$(dns_get_record_ip "$DOMAIN" "$PROVIDER" || echo "")
    
    # Determine DNS status
    local DNS_STATUS="ERROR"
    if [[ -n "$CURRENT_IP" ]]; then
      if [[ -n "$SERVER_IP" ]] && [[ "$SERVER_IP" != "Unknown" ]] && [[ "$CURRENT_IP" == "$SERVER_IP" ]]; then
        DNS_STATUS="OK"
      elif [[ -n "$SERVER_IP" ]] && [[ "$SERVER_IP" != "Unknown" ]]; then
        DNS_STATUS="WARNING"
      else
        # Server IP unknown, can't validate
        DNS_STATUS="UNKNOWN"
      fi
    fi
    
    # Try to get hosted zone if provider is AWS and ready
    local HOSTED_ZONE="-"
    local ZONE_ID=""
    if [[ "$PROVIDER" == "aws" ]] && [[ "$SYNC_STATUS" == "Ready" ]]; then
      if declare -f "dns_provider_aws_get_hosted_zone_id" >/dev/null 2>&1; then
        ZONE_ID=$(dns_provider_aws_get_hosted_zone_id "$DOMAIN" 2>/dev/null || echo "")
        if [[ -n "$ZONE_ID" ]]; then
          # Get the zone name from AWS
          local ZONE_NAME
          ZONE_NAME=$(aws route53 get-hosted-zone --id "$ZONE_ID" --query 'HostedZone.Name' --output text 2>/dev/null | sed 's/\.$//g' || echo "$ZONE_ID")
          HOSTED_ZONE="$ZONE_NAME"
        else
          HOSTED_ZONE="Not found"
        fi
      fi
    fi
    
    # Check domain status - consider both DNS add status and hosted zone
    local DOMAIN_STATUS="Not added"
    if [[ "$APP_IS_ADDED" == "true" ]]; then
      # App has been added to DNS, check hosted zone status
      if [[ "$PROVIDER" == "aws" ]] && [[ "$SYNC_STATUS" == "Ready" ]]; then
        if [[ -n "$ZONE_ID" ]]; then
          DOMAIN_STATUS="Ready"
        else
          DOMAIN_STATUS="No hosted zone"
        fi
      elif [[ "$PROVIDER" != "None" ]] && [[ "$SYNC_STATUS" == "Ready" ]]; then
        # For other providers, default to ready (they can implement their own logic)
        DOMAIN_STATUS="Ready"
      else
        DOMAIN_STATUS="Provider not ready"
      fi
    else
      # App has not been added to DNS
      DOMAIN_STATUS="Not added"
    fi
    
    # Format and display the row
    printf "%-30s %-8s %-15s %-15s %s\n" "$DOMAIN" "$DNS_STATUS" "$DOMAIN_STATUS" "$PROVIDER" "$HOSTED_ZONE"
  done

  # Show pending changes if provider is ready
  if [[ "$PROVIDER" != "None" ]] && [[ "$SYNC_STATUS" == "Ready" ]]; then
    dns_display_pending_changes "$APP"
  fi

}

# Helper functions for DNS records to be deleted
show_records_to_be_deleted_summary() {
  local records_to_be_deleted
  records_to_be_deleted=$(get_records_to_be_deleted)
  
  if [[ -z "$records_to_be_deleted" ]]; then
    return 0
  fi
  
  local records_count
  records_count=$(echo "$records_to_be_deleted" | wc -l)
  
  echo
  dokku_log_info2 "DNS Cleanup Candidates:"
  dokku_log_info1 "Found $records_count DNS records that no longer correspond to active apps:"
  echo
  
  while IFS= read -r record; do
    [[ -z "$record" ]] && continue
    echo "  - $record (A record)"
  done <<< "$records_to_be_deleted"
  
  echo
  dokku_log_info1 "To clean up: dokku $PLUGIN_COMMAND_PREFIX:sync:deletions"
}

get_records_to_be_deleted() {
  # Get list of all current Dokku app domains
  local current_domains=()
  local apps
  apps=$(dokku apps:list 2>/dev/null | tail -n +2 | tr '\n' ' ')
  
  for app in $apps; do
    local app_domains
    app_domains=$(get_app_domains "$app" 2>/dev/null || echo "")
    if [[ -n "$app_domains" ]]; then
      while IFS= read -r domain; do
        [[ -n "$domain" ]] && current_domains+=("$domain")
      done <<< "$app_domains"
    fi
  done
  
  # Get enabled zones
  local zones_to_scan=()
  if [[ -f "$PLUGIN_DATA_ROOT/ZONES_ENABLED" ]]; then
    while IFS= read -r enabled_zone; do
      [[ -n "$enabled_zone" ]] && zones_to_scan+=("$enabled_zone")
    done < "$PLUGIN_DATA_ROOT/ZONES_ENABLED"
  fi
  
  if [[ ${#zones_to_scan[@]} -eq 0 ]]; then
    return 0
  fi
  
  # Scan each zone for records to be deleted
  local records_to_be_deleted=()
  for zone in "${zones_to_scan[@]}"; do
    local zone_id
    zone_id=$(dns_provider_aws_get_hosted_zone_id "$zone" 2>/dev/null || echo "")
    
    if [[ -z "$zone_id" ]]; then
      continue
    fi
    
    # Get all A records in this zone
    local zone_records
    zone_records=$(aws route53 list-resource-record-sets \
      --hosted-zone-id "$zone_id" \
      --query "ResourceRecordSets[?Type=='A' && !contains(Name, 'www.')].Name" \
      --output text 2>/dev/null | tr '\t' '\n' || echo "")
    
    if [[ -z "$zone_records" ]]; then
      continue
    fi
    
    # Check each DNS record against current domains
    while IFS= read -r dns_record; do
      [[ -z "$dns_record" ]] && continue
      
      # Remove trailing dot from Route53 record name
      dns_record="${dns_record%.}"
      
      # Check if this DNS record corresponds to any current domain
      local should_be_deleted=true
      for current_domain in "${current_domains[@]}"; do
        if [[ "$dns_record" == "$current_domain" ]]; then
          should_be_deleted=false
          break
        fi
      done
      
      if [[ "$should_be_deleted" == "true" ]]; then
        echo "$dns_record"
      fi
    done <<< "$zone_records"
  done
}

count_records_to_be_deleted() {
  local records_to_be_deleted
  records_to_be_deleted=$(get_records_to_be_deleted)
  
  if [[ -z "$records_to_be_deleted" ]]; then
    echo "0"
  else
    echo "$records_to_be_deleted" | wc -l
  fi
}

service-report-cmd "$@"