#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from __future__ import print_function

import os
import re


def compile(
    service,
    version,
    variable,
    alias,
    image,
    scheme,
    ports,
    sponsors,
    options,
    unimplemented,
    dokku_version,
):
    prefix = "\n\n".join(
        [
            header(service),
            description(service, image, version),
        ]
    )

    if len(sponsors) > 0:
        prefix += "\n\n"
        prefix += sponsors_section(service, sponsors)

    return (
        "\n\n".join(
            [
                prefix,
                requirements_section(dokku_version),
                installation_section(service, dokku_version),
                commands_section(
                    service, variable, alias, image, scheme, ports, unimplemented
                ),
                usage_section(
                    service,
                    variable,
                    alias,
                    image,
                    scheme,
                    ports,
                    options,
                    unimplemented,
                ),
            ]
        )
        .replace("\n\n\n\n\n", "\n")
        .replace("\n\n\n\n", "\n")
        .replace("\n\n\n", "\n\n")
    )


def header(service):
    return " ".join(
        [
            f"# dokku {service}",
            f'[![Build Status](https://img.shields.io/github/actions/workflow/status/deanmarano/dokku-{service}/ci.yml?branch=main&style=flat-square "Build Status")](https://github.com/deanmarano/dokku-{service}/actions/workflows/ci.yml?query=branch%3Amain)',
            f'[![IRC Network](https://img.shields.io/badge/irc-libera-blue.svg?style=flat-square "IRC Libera")](https://webchat.libera.chat/?channels=dokku)',
        ]
    )


def description(service, full_image, version):
    # Handle DNS plugin (no service container)
    if service == "dns":
        return """**Automated DNS management for Dokku apps with multi-provider support**

Seamlessly manage DNS records for your Dokku applications across multiple cloud providers including AWS Route53, Cloudflare, and DigitalOcean. Automatically create, update, and synchronize DNS records as you deploy and manage your apps.

## âœ¨ Key Features

- ðŸ¤– **Fully Automatic**: Enable triggers once, never think about DNS again - records are created, updated, and cleaned up automatically
- ðŸš€ **Multi-Provider Support**: AWS Route53, Cloudflare, DigitalOcean, and extensible architecture for more providers
- ðŸ”„ **Lifecycle Integration**: Hooks into Dokku's app lifecycle (create, domains add/remove, destroy) for seamless DNS management
- ðŸŽ¯ **Zone-Based Routing**: Intelligent routing of domains to appropriate DNS providers
- âš¡ **Batch Operations**: Efficient bulk DNS updates across all your apps
- ðŸ•’ **TTL Management**: Flexible TTL configuration at global, zone, and domain levels (default: 300 seconds)

## ðŸš€ Quick Start

### 1. Install the Plugin

```shell
sudo dokku plugin:install https://github.com/deanmarano/dokku-dns.git --name dns
```

### 2. Configure Your DNS Provider

**Option A: AWS Route53**
```shell
dokku config:set --global AWS_ACCESS_KEY_ID=your_key AWS_SECRET_ACCESS_KEY=your_secret
dokku dns:providers:verify aws
```

**Option B: Cloudflare**
```shell
dokku config:set --global CLOUDFLARE_API_TOKEN=your_api_token
dokku dns:providers:verify cloudflare
```

**Option C: DigitalOcean**
```shell
dokku config:set --global DIGITALOCEAN_ACCESS_TOKEN=your_api_token
dokku dns:providers:verify digitalocean
```

### 3. Enable Automatic DNS Management

```shell
# Enable zones you want to manage
dokku dns:zones:enable example.com

# Enable automatic triggers (RECOMMENDED)
dokku dns:triggers:enable
```

ðŸŽ‰ **That's it!** DNS is now fully automatic. The plugin will:
- âœ… **Automatically add domains** to DNS when you run `dokku domains:add`
- âœ… **Automatically create DNS records** pointing to your server
- âœ… **Automatically queue cleanup** when you remove domains or destroy apps

### Example: Add Domains to Your Existing Apps

```shell
# Add domains to your existing app - DNS records are created automatically!
dokku domains:add myapp example.com
dokku domains:add myapp www.example.com

# Check DNS status
dokku dns:report myapp
```

## ðŸ¤– How Automatic DNS Management Works

When you enable triggers with `dokku dns:triggers:enable` and enable zones with `dokku dns:zones:enable`, the plugin automatically manages DNS for your apps without any manual intervention.

### When You Add a Domain

```shell
dokku domains:add myapp example.com
```

**What happens automatically:**
1. âœ… Plugin detects the domain was added (via `post-domains-update` trigger)
2. âœ… Checks if `example.com` is in an enabled zone
3. âœ… Adds the domain to DNS tracking for `myapp`
4. âœ… **Automatically syncs DNS** - creates an A record pointing to your server
5. âœ… Confirms DNS record created successfully

**Result:** The domain is immediately accessible via DNS, no manual sync needed!

### When You Remove a Domain

```shell
dokku domains:remove myapp example.com
```

**What happens automatically:**
1. âœ… Plugin detects the domain was removed (via `post-domains-update` trigger)
2. âœ… Removes the domain from DNS tracking
3. âœ… **Queues the DNS record for cleanup**
4. â³ DNS record stays in place temporarily (safety feature)

**Manual cleanup step:**
- ðŸ§¹ Run `dokku dns:sync:deletions` when ready to remove DNS records

**Why queue deletions?** This prevents accidental DNS disruption. You control when orphaned records are actually deleted.

### When You Destroy an App

```shell
dokku apps:destroy myapp
```

**What happens automatically:**
1. âœ… Plugin detects the app was destroyed (via `post-delete` trigger)
2. âœ… Removes all DNS tracking for the app
3. âœ… **Queues all domains for cleanup**
4. âœ… Removes app from DNS management

**Manual cleanup step:**
- ðŸ§¹ Run `dokku dns:sync:deletions` to clean up DNS records

### Manual Mode (Without Triggers)

If you prefer manual control, you can disable triggers and manage DNS explicitly:

```shell
# Disable automatic management
dokku dns:triggers:disable

# Manual workflow
dokku domains:add myapp example.com    # Add domain
dokku dns:apps:enable myapp            # Enable DNS management
dokku dns:apps:sync myapp              # Manually sync DNS records
```"""
    
    base = "_"
    image = full_image
    if "/" in full_image:
        base = "r/" + full_image.split("/")[0]
        image = full_image.split("/")[1]

    return f"A {service} plugin for dokku. Currently defaults to installing [{full_image} {version}](https://hub.docker.com/{base}/{image}/)."


def sponsors_section(service, sponsors):
    if len(sponsors) == 0:
        return ""

    sponsor_data = [
        "## Sponsors",
        "",
        f"The {service} plugin was generously sponsored by the following:",
        "",
    ]
    sponsor_data.extend([f"- [{s}](https://github.com/{s})" for s in sponsors])

    return "\n".join(sponsor_data)


def requirements_section(dokku_version):
    return "\n".join(
        [
            "## Requirements",
            "",
            f"- dokku {dokku_version}",
            "- docker 1.8.x",
            "- DNS provider credentials (AWS Route53, Cloudflare, or DigitalOcean)",
        ]
    )


def installation_section(service, dokku_version):
    return "\n".join(
        [
            "## Installation",
            "",
            "```shell",
            f"# on {dokku_version}",
            f"sudo dokku plugin:install https://github.com/deanmarano/dokku-{service}.git --name {service}",
            "```",
        ]
    )


def commands_section(service, variable, alias, image, scheme, ports, unimplemented):
    content = [
        "## Commands",
        "",
        "```",
    ]

    subcommands = os.listdir("subcommands")
    subcommands.sort()

    command_list = []
    descriptions = []
    for filename in subcommands:
        if filename in unimplemented:
            continue
            
        data = command_data(filename, service, variable, alias, image, scheme, ports)
        description = data["description"]
        arguments = data["arguments_string"]

        command_list.append(f"{service}:{filename} {arguments}")
        descriptions.append(description)

    maxlen = max(map(len, command_list))
    if maxlen > 50:
        maxlen = 50
    for command, description in zip(command_list, descriptions):
        space_count = maxlen - len(command)
        content.append("{0}{1} # {2}".format(command, " " * space_count, description))

    content.append("```")
    return "\n".join(content)


def usage_section(
    service, variable, alias, image, scheme, ports, options, unimplemented
):
    return "\n\n".join(
        [
            "## Usage",
            f"Help for any commands can be displayed by specifying the command as an argument to {service}:help. Plugin help output in conjunction with any files in the `docs/` folder is used to generate the plugin documentation. Please consult the `{service}:help` command for any undocumented commands.",
            usage_intro(
                service, variable, alias, image, scheme, ports, options, unimplemented
            ),
            usage_lifecycle(
                service, variable, alias, image, scheme, ports, options, unimplemented
            ),
            usage_automation(
                service, variable, alias, image, scheme, ports, options, unimplemented
            ),
            usage_data_management(
                service, variable, alias, image, scheme, ports, options, unimplemented
            ),
            usage_backup(
                service, variable, alias, image, scheme, ports, options, unimplemented
            ),
        ]
    )


def usage_intro(service, variable, alias, image, scheme, ports, options, unimplemented):
    commands = ["apps:enable", "providers:verify", "report", "apps:sync", "sync-all"]
    content = ["### Basic Usage"]

    return fetch_commands_content(
        service,
        variable,
        alias,
        image,
        scheme,
        ports,
        options,
        unimplemented,
        commands,
        content,
    )


def usage_lifecycle(
    service, variable, alias, image, scheme, ports, options, unimplemented
):
    commands = [
        "connect",
        "enter",
        "expose",
        "unexpose",
        "promote",
        "start",
        "stop",
        "pause",
        "restart",
        "upgrade",
    ]
    content = [
        "### Service Lifecycle",
        "",
        "The lifecycle of each service can be managed through the following commands:",
        "",
    ]

    return fetch_commands_content(
        service,
        variable,
        alias,
        image,
        scheme,
        ports,
        options,
        unimplemented,
        commands,
        content,
    )


def usage_automation(
    service, variable, alias, image, scheme, ports, options, unimplemented
):
    commands = ["app-links", "clone", "exists", "linked", "links"]
    content = [
        "### Service Automation",
        "",
        "Service scripting can be executed using the following commands:",
        "",
    ]

    return fetch_commands_content(
        service,
        variable,
        alias,
        image,
        scheme,
        ports,
        options,
        unimplemented,
        commands,
        content,
    )


def usage_data_management(
    service, variable, alias, image, scheme, ports, options, unimplemented
):
    commands = ["import", "export"]
    content = [
        "### Data Management",
        "",
        "The underlying service data can be imported and exported with the following commands:",
        "",
    ]

    return fetch_commands_content(
        service,
        variable,
        alias,
        image,
        scheme,
        ports,
        options,
        unimplemented,
        commands,
        content,
    )


def usage_backup(
    service, variable, alias, image, scheme, ports, options, unimplemented
):
    commands = [
        "backup-auth",
        "backup-deauth",
        "backup",
        "backup-set-encryption",
        "backup-set-public-key-encryption",
        "backup-unset-encryption",
        "backup-unset-public-key-encryption",
        "backup-schedule",
        "backup-schedule-cat",
        "backup-unschedule",
    ]
    content = [
        "### Backups",
        "",
        "Datastore backups are supported via AWS S3 and S3 compatible services like [minio](https://github.com/minio/minio).",
        "",
        "You may skip the `backup-auth` step if your dokku install is running within EC2 and has access to the bucket via an IAM profile. In that case, use the `--use-iam` option with the `backup` command.",
        "",
        "Backups can be performed using the backup commands:",
        "",
    ]

    return fetch_commands_content(
        service,
        variable,
        alias,
        image,
        scheme,
        ports,
        options,
        unimplemented,
        commands,
        content,
    )


def usage_docker_pull(
    service, variable, alias, image, scheme, ports, options, unimplemented
):
    service_prefix = service.upper()
    return "\n".join(
        [
            "### Disabling `docker image pull` calls",
            "",
            f"If you wish to disable the `docker image pull` calls that the plugin triggers, you may set the `{service_prefix}_DISABLE_PULL` environment variable to `true`. Once disabled, you will need to pull the service image you wish to deploy as shown in the `stderr` output.",
            "",
            "Please ensure the proper images are in place when `docker image pull` is disabled.",
        ]
    )


def fetch_commands_content(
    service,
    variable,
    alias,
    image,
    scheme,
    ports,
    options,
    unimplemented,
    commands,
    content,
):
    i = 0
    for command in commands:
        output = command_help(
            command,
            service,
            variable,
            alias,
            image,
            scheme,
            ports,
            options,
            unimplemented,
        )
        if output == "":
            continue
        content.append(output)
        i += 1

    if i == 0:
        return ""

    return "\n".join(content)


def parse_args(line):
    line = line.strip()
    arguments = []
    for arg in re.findall("([A-Z_]+)", line):
        arg = arg.replace("_", "-").lower()
        if arg.endswith("optional-flag"):
            arg = arg.replace("-optional-flag", "")
            arguments.append(f"[--{arg}]")
        elif arg.endswith("-flag"):
            if arg == "info-flag":
                arguments.append(f"[--single-info-flag]")
            else:
                arg = arg.replace("-flag", "")
                first_letter = arg[0]
                arguments.append(f"[-{first_letter}|--{arg}]")
        elif arg.endswith("-flags-list"):
            arg = arg.replace("-list", "")
            arguments.append(f"[--{arg}...]")
        elif arg.endswith("list"):
            arg = arg.replace("-list", "")
            arguments.append(f"<{arg}...>")
        else:
            arguments.append(f"<{arg}>")
    return " ".join(arguments)


def command_help(
    command, service, variable, alias, image, scheme, ports, options, unimplemented
):
    if command in unimplemented:
        return ""

    data = command_data(command, service, variable, alias, image, scheme, ports)
    content = [
        f"### {data['description']}",
        "",
        "```shell",
        "# usage",
        f"dokku {service}:{command} {data['arguments_string']}".strip(),
        "```",
    ]

    # if len(data["arguments"]) > 0:
    #     content.append("")
    #     content.append("arguments:")
    #     content.append("")
    # for argument in data["arguments"]:
    #     content.append(f"- {argument}")

    if len(data["flags"]) > 0:
        content.append("")
        content.append("flags:")
        content.append("")
    for flag in data["flags"]:
        if "--config-options" in flag and options != "":
            flag = f"{flag} (default: `{options}`)"
        content.append(f"- {flag}")

    if len(data["examples"]) > 0:
        content.append("")
        content.append(data["examples"])

    doc_file = os.path.join("docs", f"{command}.md")
    if os.path.isfile(doc_file):
        content.append("")
        with open(doc_file) as f:
            content.append(f.read())

    return "\n" + "\n".join(content)


def command_data(command, service, variable, alias, image, scheme, ports):
    description = None
    arguments = []
    arguments_string = ""
    example_lines = []
    flags = []
    optional_arguments = set()
    
    with open(os.path.join("subcommands", command)) as f:
        for line in f.readlines():
            line = line.strip()
            line = line.replace("$PLUGIN_SERVICE", service)
            line = line.replace("$PLUGIN_COMMAND_PREFIX", service)
            line = line.replace("${PLUGIN_COMMAND_PREFIX}", service)
            line = line.replace("${PLUGIN_VARIABLE}", variable)
            line = line.replace("${PLUGIN_DEFAULT_ALIAS}", alias)
            line = line.replace("${PLUGIN_IMAGE}", image)
            line = line.replace("${PLUGIN_SCHEME}", scheme)
            line = line.replace("${PLUGIN_DATASTORE_PORTS[0]}", ports[0])
            line = line.replace("${PLUGIN_DATASTORE_PORTS[@]}", " ".join(ports))

            if "declare desc" in line:
                description = re.search('"(.+)"', line).group(1)
            elif "$1" in line and ("=" in line or "declare" in line):
                # Only parse lines that are actually declaring arguments, not conditional statements or awk commands
                if not line.strip().startswith("#") and not "awk" in line and not "echo" in line and not "if [" in line:
                    # Look for patterns like: SERVICE_ARG="$1" or similar argument declarations
                    if re.search(r'\b[A-Z_]+\s*=\s*["\']?\$1["\']?', line):
                        arguments_string = parse_args(line)
            elif line.startswith("#A "):
                argument = line.replace("#A ", "")
                parts = [a.strip() for a in argument.split(",", 1)]
                arguments.append(f"`{parts[0]}`: {parts[1]}")
                # Check if argument is marked as optional
                if len(parts) > 1 and "(optional)" in parts[1].lower():
                    optional_arguments.add(parts[0])
            elif line.startswith("#F "):
                flag = line.replace("#F ", "")
                parts = [a.strip() for a in flag.split(",", 1)]
                flags.append(f"`{parts[0]}`: {parts[1]}")
            elif line.startswith("#E "):
                example_lines.append(line.replace("#E ", ""))

    # Special handling for commands with flags but no positional arguments
    if not arguments_string and flags and command == "cron":
        # For cron command, show the simplified usage pattern
        arguments_string = "[--enable|--disable|--schedule \"CRON_SCHEDULE\"]"

    # Post-process arguments_string to make optional arguments bracketed
    if arguments_string and optional_arguments:
        for opt_arg in optional_arguments:
            # Convert <arg> to [<arg>] for optional arguments
            arguments_string = arguments_string.replace(f"<{opt_arg}>", f"[<{opt_arg}>]")
    examples = []
    sentence_lines = []
    command_lines = []
    codeblock_lines = []
    blockquote_lines = []
    for line in example_lines:
        if line.startswith("export") or line.startswith("dokku"):
            if len(blockquote_lines) > 0:
                examples.append("\n" + process_blockquote(blockquote_lines))
                blockquote_lines = []
            if len(codeblock_lines) > 0:
                examples.append("\n" + process_codeblock(codeblock_lines))
                codeblock_lines = []
            if len(sentence_lines) > 0:
                examples.append("\n" + process_sentence(sentence_lines))
                sentence_lines = []

            command_lines.append(line)
        elif line.startswith("    "):
            if len(blockquote_lines) > 0:
                examples.append("\n" + process_blockquote(blockquote_lines))
                blockquote_lines = []
            if len(command_lines) > 0:
                examples.append("\n" + process_command(command_lines))
                command_lines = []
            if len(sentence_lines) > 0:
                examples.append("\n" + process_sentence(sentence_lines))
                sentence_lines = []

            codeblock_lines.append(line.strip())
        elif line.startswith(">"):
            if len(codeblock_lines) > 0:
                examples.append("\n" + process_codeblock(codeblock_lines))
                codeblock_lines = []
            if len(command_lines) > 0:
                examples.append("\n" + process_command(command_lines))
                command_lines = []
            if len(sentence_lines) > 0:
                examples.append("\n" + process_sentence(sentence_lines))
                sentence_lines = []

            blockquote_lines.append(line)
        else:
            if len(blockquote_lines) > 0:
                examples.append("\n" + process_blockquote(blockquote_lines))
                blockquote_lines = []
            if len(codeblock_lines) > 0:
                examples.append("\n" + process_codeblock(codeblock_lines))
                codeblock_lines = []
            if len(command_lines) > 0:
                examples.append("\n" + process_command(command_lines))
                command_lines = []

            sentence_lines.append(line)

    if len(blockquote_lines) > 0:
        examples.append("\n" + process_blockquote(blockquote_lines))
        blockquote_lines = []
    if len(codeblock_lines) > 0:
        examples.append("\n" + process_codeblock(codeblock_lines))
        codeblock_lines = []
    if len(command_lines) > 0:
        examples.append("\n" + process_command(command_lines))
        command_lines = []
    if len(sentence_lines) > 0:
        examples.append("\n" + process_sentence(sentence_lines))
        sentence_lines = []

    return {
        "description": description,
        "arguments_string": arguments_string,
        "arguments": arguments,
        "flags": flags,
        "examples": "\n".join(examples).strip(),
    }


def process_sentence(sentence_lines):
    sentence_lines = " ".join(sentence_lines)
    sentences = ". ".join(
        upperfirst(i.strip()) for i in sentence_lines.split(". ")
    ).strip()
    if not sentences.endswith(".") and not sentences.endswith(":"):
        sentences += ":"

    text = []
    for sentence in sentences.split(". "):
        parts = []
        for word in sentence.strip().split(" "):
            if word.isupper() and len(word) > 1:
                for ending in [":", "."]:
                    if word.endswith(ending):
                        word = "`{0}`{1}".format(word[:-1], ending)
                else:
                    word = "`{0}`".format(word)
            parts.append(word)
        text.append(" ".join(parts))

    text = ". ".join(text)

    # some cleanup
    text = text.replace("(0.0.0.0)", "(`0.0.0.0`)")
    text = text.replace("'", "`")
    text = text.replace("`s", "'s")
    text = text.replace("``", "`")
    text = text.strip(" ")

    return text


def upperfirst(x):
    return x[:1].upper() + x[1:]


def process_blockquote(blockquote_lines):
    return "\n".join(blockquote_lines)


def process_command(command_lines):
    command_lines = "\n".join(command_lines)
    return f"```shell\n{command_lines}\n```"


def process_codeblock(codeblock_lines):
    codeblock_lines = "\n".join(codeblock_lines)
    return f"```\n{codeblock_lines}\n```"


def main():
    service = None
    version = None
    variable = None
    image = None
    alias = None
    scheme = None
    ports = []
    options = None
    unimplemented = []

    # Handle DNS plugin (no service container)
    try:
        with open("Dockerfile") as f:
            for line in f.readlines():
                if "FROM " in line:
                    image, version = line.split(" ")[1].split(":")
                    image = image.strip()
                    version = version.strip()
    except FileNotFoundError:
        # DNS plugin doesn't need a service container
        image = "N/A"
        version = "N/A"

    with open("config") as f:
        for line in f.readlines():
            if "PLUGIN_COMMAND_PREFIX=" in line:
                service = re.search('"(.+)"', line).group(1)
            if "PLUGIN_DEFAULT_ALIAS=" in line:
                alias = re.search('"(.+)"', line).group(1)
            if "PLUGIN_VARIABLE=" in line:
                variable = re.search('"(.+)"', line).group(1)
            if "PLUGIN_SCHEME=" in line:
                scheme = re.search('"(.+)"', line).group(1)
            if "PLUGIN_DATASTORE_PORTS=" in line:
                ports = re.search(r"\((.+)\)", line).group(1).split(" ")
            if "PLUGIN_UNIMPLEMENTED_SUBCOMMANDS=" in line:
                match = re.search(r"\((.+)\)", line)
                if match is not None:
                    unimplemented = [s.strip('"') for s in match.group(1).split(" ")]

    with open("config") as f:
        for line in f.readlines():
            if f"{variable}_CONFIG_OPTIONS" in line:
                match = re.search('"(.+)"', line)
                if match is not None:
                    options = match.group(1)

    sponsors = []
    with open("plugin.toml") as f:
        for line in f.readlines():
            if line.startswith("sponsors"):
                sponsors = re.search(r'\[(["\w\s,_-]+)\]', line).group(1)
                sponsors = [s.strip('"') for s in sponsors.split(",")]

    text = compile(
        service,
        version,
        variable,
        alias,
        image,
        scheme,
        ports,
        sponsors,
        options,
        unimplemented,
        "0.19.x+",
    )

    base_path = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
    readme_file = os.path.join(base_path, "README.md")
    with open(readme_file, "w") as f:
        f.write(text + "\n")


if __name__ == "__main__":
    main()
